// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: livekit_models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2023 LiveKit, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Livekit_AudioCodec: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case defaultAc // = 0
  case opus // = 1
  case aac // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .defaultAc
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .defaultAc
    case 1: self = .opus
    case 2: self = .aac
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .defaultAc: return 0
    case .opus: return 1
    case .aac: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Livekit_AudioCodec] = [
    .defaultAc,
    .opus,
    .aac,
  ]

}

enum Livekit_VideoCodec: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case defaultVc // = 0
  case h264Baseline // = 1
  case h264Main // = 2
  case h264High // = 3
  case vp8 // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .defaultVc
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .defaultVc
    case 1: self = .h264Baseline
    case 2: self = .h264Main
    case 3: self = .h264High
    case 4: self = .vp8
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .defaultVc: return 0
    case .h264Baseline: return 1
    case .h264Main: return 2
    case .h264High: return 3
    case .vp8: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Livekit_VideoCodec] = [
    .defaultVc,
    .h264Baseline,
    .h264Main,
    .h264High,
    .vp8,
  ]

}

enum Livekit_ImageCodec: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case icDefault // = 0
  case icJpeg // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .icDefault
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .icDefault
    case 1: self = .icJpeg
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .icDefault: return 0
    case .icJpeg: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Livekit_ImageCodec] = [
    .icDefault,
    .icJpeg,
  ]

}

/// Policy for publisher to handle subscribers that are unable to support the primary codec of a track
enum Livekit_BackupCodecPolicy: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// default behavior, the track prefer to regress to backup codec and all subscribers will receive the backup codec,
  /// the sfu will try to regress codec if possible but not assured.
  case preferRegression // = 0

  /// encoding/send the primary and backup codec simultaneously
  case simulcast // = 1

  /// force the track to regress to backup codec, this option can be used in video conference or the publisher has limited bandwidth/encoding power
  case regression // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .preferRegression
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .preferRegression
    case 1: self = .simulcast
    case 2: self = .regression
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .preferRegression: return 0
    case .simulcast: return 1
    case .regression: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Livekit_BackupCodecPolicy] = [
    .preferRegression,
    .simulcast,
    .regression,
  ]

}

enum Livekit_TrackType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case audio // = 0
  case video // = 1
  case data // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .audio
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .audio
    case 1: self = .video
    case 2: self = .data
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .audio: return 0
    case .video: return 1
    case .data: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Livekit_TrackType] = [
    .audio,
    .video,
    .data,
  ]

}

enum Livekit_TrackSource: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case camera // = 1
  case microphone // = 2
  case screenShare // = 3
  case screenShareAudio // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .camera
    case 2: self = .microphone
    case 3: self = .screenShare
    case 4: self = .screenShareAudio
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .camera: return 1
    case .microphone: return 2
    case .screenShare: return 3
    case .screenShareAudio: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Livekit_TrackSource] = [
    .unknown,
    .camera,
    .microphone,
    .screenShare,
    .screenShareAudio,
  ]

}

enum Livekit_VideoQuality: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case low // = 0
  case medium // = 1
  case high // = 2
  case off // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .low
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .low
    case 1: self = .medium
    case 2: self = .high
    case 3: self = .off
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .low: return 0
    case .medium: return 1
    case .high: return 2
    case .off: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Livekit_VideoQuality] = [
    .low,
    .medium,
    .high,
    .off,
  ]

}

enum Livekit_ConnectionQuality: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case poor // = 0
  case good // = 1
  case excellent // = 2
  case lost // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .poor
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .poor
    case 1: self = .good
    case 2: self = .excellent
    case 3: self = .lost
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .poor: return 0
    case .good: return 1
    case .excellent: return 2
    case .lost: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Livekit_ConnectionQuality] = [
    .poor,
    .good,
    .excellent,
    .lost,
  ]

}

enum Livekit_ClientConfigSetting: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unset // = 0
  case disabled // = 1
  case enabled // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unset
    case 1: self = .disabled
    case 2: self = .enabled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unset: return 0
    case .disabled: return 1
    case .enabled: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Livekit_ClientConfigSetting] = [
    .unset,
    .disabled,
    .enabled,
  ]

}

enum Livekit_DisconnectReason: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknownReason // = 0

  /// the client initiated the disconnect
  case clientInitiated // = 1

  /// another participant with the same identity has joined the room
  case duplicateIdentity // = 2

  /// the server instance is shutting down
  case serverShutdown // = 3

  /// RoomService.RemoveParticipant was called
  case participantRemoved // = 4

  /// RoomService.DeleteRoom was called
  case roomDeleted // = 5

  /// the client is attempting to resume a session, but server is not aware of it
  case stateMismatch // = 6

  /// client was unable to connect fully
  case joinFailure // = 7

  /// Cloud-only, the server requested Participant to migrate the connection elsewhere
  case migration // = 8

  /// the signal websocket was closed unexpectedly
  case signalClose // = 9

  /// the room was closed, due to all Standard and Ingress participants having left
  case roomClosed // = 10

  /// SIP callee did not respond in time
  case userUnavailable // = 11

  /// SIP callee rejected the call (busy)
  case userRejected // = 12

  /// SIP protocol failure or unexpected response
  case sipTrunkFailure // = 13

  /// server timed out a participant session
  case connectionTimeout // = 14

  /// media stream failure or media timeout
  case mediaFailure // = 15
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownReason
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownReason
    case 1: self = .clientInitiated
    case 2: self = .duplicateIdentity
    case 3: self = .serverShutdown
    case 4: self = .participantRemoved
    case 5: self = .roomDeleted
    case 6: self = .stateMismatch
    case 7: self = .joinFailure
    case 8: self = .migration
    case 9: self = .signalClose
    case 10: self = .roomClosed
    case 11: self = .userUnavailable
    case 12: self = .userRejected
    case 13: self = .sipTrunkFailure
    case 14: self = .connectionTimeout
    case 15: self = .mediaFailure
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownReason: return 0
    case .clientInitiated: return 1
    case .duplicateIdentity: return 2
    case .serverShutdown: return 3
    case .participantRemoved: return 4
    case .roomDeleted: return 5
    case .stateMismatch: return 6
    case .joinFailure: return 7
    case .migration: return 8
    case .signalClose: return 9
    case .roomClosed: return 10
    case .userUnavailable: return 11
    case .userRejected: return 12
    case .sipTrunkFailure: return 13
    case .connectionTimeout: return 14
    case .mediaFailure: return 15
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Livekit_DisconnectReason] = [
    .unknownReason,
    .clientInitiated,
    .duplicateIdentity,
    .serverShutdown,
    .participantRemoved,
    .roomDeleted,
    .stateMismatch,
    .joinFailure,
    .migration,
    .signalClose,
    .roomClosed,
    .userUnavailable,
    .userRejected,
    .sipTrunkFailure,
    .connectionTimeout,
    .mediaFailure,
  ]

}

enum Livekit_ReconnectReason: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case rrUnknown // = 0
  case rrSignalDisconnected // = 1
  case rrPublisherFailed // = 2
  case rrSubscriberFailed // = 3
  case rrSwitchCandidate // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .rrUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rrUnknown
    case 1: self = .rrSignalDisconnected
    case 2: self = .rrPublisherFailed
    case 3: self = .rrSubscriberFailed
    case 4: self = .rrSwitchCandidate
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .rrUnknown: return 0
    case .rrSignalDisconnected: return 1
    case .rrPublisherFailed: return 2
    case .rrSubscriberFailed: return 3
    case .rrSwitchCandidate: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Livekit_ReconnectReason] = [
    .rrUnknown,
    .rrSignalDisconnected,
    .rrPublisherFailed,
    .rrSubscriberFailed,
    .rrSwitchCandidate,
  ]

}

enum Livekit_SubscriptionError: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case seUnknown // = 0
  case seCodecUnsupported // = 1
  case seTrackNotfound // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .seUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .seUnknown
    case 1: self = .seCodecUnsupported
    case 2: self = .seTrackNotfound
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .seUnknown: return 0
    case .seCodecUnsupported: return 1
    case .seTrackNotfound: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Livekit_SubscriptionError] = [
    .seUnknown,
    .seCodecUnsupported,
    .seTrackNotfound,
  ]

}

enum Livekit_AudioTrackFeature: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case tfStereo // = 0
  case tfNoDtx // = 1
  case tfAutoGainControl // = 2
  case tfEchoCancellation // = 3
  case tfNoiseSuppression // = 4
  case tfEnhancedNoiseCancellation // = 5

  /// client will buffer audio once available and send it to the server via bytes stream once connected
  case tfPreconnectBuffer // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .tfStereo
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tfStereo
    case 1: self = .tfNoDtx
    case 2: self = .tfAutoGainControl
    case 3: self = .tfEchoCancellation
    case 4: self = .tfNoiseSuppression
    case 5: self = .tfEnhancedNoiseCancellation
    case 6: self = .tfPreconnectBuffer
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .tfStereo: return 0
    case .tfNoDtx: return 1
    case .tfAutoGainControl: return 2
    case .tfEchoCancellation: return 3
    case .tfNoiseSuppression: return 4
    case .tfEnhancedNoiseCancellation: return 5
    case .tfPreconnectBuffer: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Livekit_AudioTrackFeature] = [
    .tfStereo,
    .tfNoDtx,
    .tfAutoGainControl,
    .tfEchoCancellation,
    .tfNoiseSuppression,
    .tfEnhancedNoiseCancellation,
    .tfPreconnectBuffer,
  ]

}

struct Livekit_Pagination: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// list entities which IDs are greater
  var afterID: String = String()

  var limit: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListUpdate is used for updated APIs where 'repeated string' field is modified.
struct Livekit_ListUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// set the field to a new list
  var set: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_Room: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sid: String = String()

  var name: String = String()

  var emptyTimeout: UInt32 = 0

  var departureTimeout: UInt32 = 0

  var maxParticipants: UInt32 = 0

  var creationTime: Int64 = 0

  var creationTimeMs: Int64 = 0

  var turnPassword: String = String()

  var enabledCodecs: [Livekit_Codec] = []

  var metadata: String = String()

  var numParticipants: UInt32 = 0

  var numPublishers: UInt32 = 0

  var activeRecording: Bool = false

  var version: Livekit_TimedVersion {
    get {return _version ?? Livekit_TimedVersion()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: Livekit_TimedVersion? = nil
}

struct Livekit_Codec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mime: String = String()

  var fmtpLine: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_PlayoutDelay: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var min: UInt32 = 0

  var max: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_ParticipantPermission: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// allow participant to subscribe to other tracks in the room
  var canSubscribe: Bool = false

  /// allow participant to publish new tracks to room
  var canPublish: Bool = false

  /// allow participant to publish data
  var canPublishData: Bool = false

  /// sources that are allowed to be published
  var canPublishSources: [Livekit_TrackSource] = []

  /// indicates that it's hidden to others
  var hidden: Bool = false

  /// indicates it's a recorder instance
  /// deprecated: use ParticipantInfo.kind instead
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var recorder: Bool = false

  /// indicates that participant can update own metadata and attributes
  var canUpdateMetadata: Bool = false

  /// indicates that participant is an agent
  /// deprecated: use ParticipantInfo.kind instead
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var agent: Bool = false

  /// if a participant can subscribe to metrics
  var canSubscribeMetrics: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_ParticipantInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sid: String {
    get {return _storage._sid}
    set {_uniqueStorage()._sid = newValue}
  }

  var identity: String {
    get {return _storage._identity}
    set {_uniqueStorage()._identity = newValue}
  }

  var state: Livekit_ParticipantInfo.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var tracks: [Livekit_TrackInfo] {
    get {return _storage._tracks}
    set {_uniqueStorage()._tracks = newValue}
  }

  var metadata: String {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  /// timestamp when participant joined room, in seconds
  var joinedAt: Int64 {
    get {return _storage._joinedAt}
    set {_uniqueStorage()._joinedAt = newValue}
  }

  /// timestamp when participant joined room, in milliseconds
  var joinedAtMs: Int64 {
    get {return _storage._joinedAtMs}
    set {_uniqueStorage()._joinedAtMs = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var version: UInt32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var permission: Livekit_ParticipantPermission {
    get {return _storage._permission ?? Livekit_ParticipantPermission()}
    set {_uniqueStorage()._permission = newValue}
  }
  /// Returns true if `permission` has been explicitly set.
  var hasPermission: Bool {return _storage._permission != nil}
  /// Clears the value of `permission`. Subsequent reads from it will return its default value.
  mutating func clearPermission() {_uniqueStorage()._permission = nil}

  var region: String {
    get {return _storage._region}
    set {_uniqueStorage()._region = newValue}
  }

  /// indicates the participant has an active publisher connection
  /// and can publish to the server
  var isPublisher: Bool {
    get {return _storage._isPublisher}
    set {_uniqueStorage()._isPublisher = newValue}
  }

  var kind: Livekit_ParticipantInfo.Kind {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  var attributes: Dictionary<String,String> {
    get {return _storage._attributes}
    set {_uniqueStorage()._attributes = newValue}
  }

  var disconnectReason: Livekit_DisconnectReason {
    get {return _storage._disconnectReason}
    set {_uniqueStorage()._disconnectReason = newValue}
  }

  var kindDetails: [Livekit_ParticipantInfo.KindDetail] {
    get {return _storage._kindDetails}
    set {_uniqueStorage()._kindDetails = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// websocket' connected, but not offered yet
    case joining // = 0

    /// server received client offer
    case joined // = 1

    /// ICE connectivity established
    case active // = 2

    /// WS disconnected
    case disconnected // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .joining
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .joining
      case 1: self = .joined
      case 2: self = .active
      case 3: self = .disconnected
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .joining: return 0
      case .joined: return 1
      case .active: return 2
      case .disconnected: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Livekit_ParticipantInfo.State] = [
      .joining,
      .joined,
      .active,
      .disconnected,
    ]

  }

  enum Kind: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// standard participants, e.g. web clients
    case standard // = 0

    /// only ingests streams
    case ingress // = 1

    /// only consumes streams
    case egress // = 2

    /// SIP participants
    case sip // = 3

    /// LiveKit agents
    case agent // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .standard
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .standard
      case 1: self = .ingress
      case 2: self = .egress
      case 3: self = .sip
      case 4: self = .agent
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .standard: return 0
      case .ingress: return 1
      case .egress: return 2
      case .sip: return 3
      case .agent: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Livekit_ParticipantInfo.Kind] = [
      .standard,
      .ingress,
      .egress,
      .sip,
      .agent,
    ]

  }

  enum KindDetail: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case cloudAgent // = 0
    case forwarded // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .cloudAgent
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .cloudAgent
      case 1: self = .forwarded
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .cloudAgent: return 0
      case .forwarded: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Livekit_ParticipantInfo.KindDetail] = [
      .cloudAgent,
      .forwarded,
    ]

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Livekit_Encryption: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case none // = 0
    case gcm // = 1
    case custom // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .gcm
      case 2: self = .custom
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .gcm: return 1
      case .custom: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Livekit_Encryption.TypeEnum] = [
      .none,
      .gcm,
      .custom,
    ]

  }

  init() {}
}

struct Livekit_SimulcastCodecInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mimeType: String = String()

  var mid: String = String()

  var cid: String = String()

  var layers: [Livekit_VideoLayer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_TrackInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sid: String {
    get {return _storage._sid}
    set {_uniqueStorage()._sid = newValue}
  }

  var type: Livekit_TrackType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var muted: Bool {
    get {return _storage._muted}
    set {_uniqueStorage()._muted = newValue}
  }

  /// original width of video (unset for audio)
  /// clients may receive a lower resolution version with simulcast
  var width: UInt32 {
    get {return _storage._width}
    set {_uniqueStorage()._width = newValue}
  }

  /// original height of video (unset for audio)
  var height: UInt32 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  /// true if track is simulcasted
  var simulcast: Bool {
    get {return _storage._simulcast}
    set {_uniqueStorage()._simulcast = newValue}
  }

  /// true if DTX (Discontinuous Transmission) is disabled for audio
  var disableDtx: Bool {
    get {return _storage._disableDtx}
    set {_uniqueStorage()._disableDtx = newValue}
  }

  /// source of media
  var source: Livekit_TrackSource {
    get {return _storage._source}
    set {_uniqueStorage()._source = newValue}
  }

  var layers: [Livekit_VideoLayer] {
    get {return _storage._layers}
    set {_uniqueStorage()._layers = newValue}
  }

  /// mime type of codec
  var mimeType: String {
    get {return _storage._mimeType}
    set {_uniqueStorage()._mimeType = newValue}
  }

  var mid: String {
    get {return _storage._mid}
    set {_uniqueStorage()._mid = newValue}
  }

  var codecs: [Livekit_SimulcastCodecInfo] {
    get {return _storage._codecs}
    set {_uniqueStorage()._codecs = newValue}
  }

  var stereo: Bool {
    get {return _storage._stereo}
    set {_uniqueStorage()._stereo = newValue}
  }

  /// true if RED (Redundant Encoding) is disabled for audio
  var disableRed: Bool {
    get {return _storage._disableRed}
    set {_uniqueStorage()._disableRed = newValue}
  }

  var encryption: Livekit_Encryption.TypeEnum {
    get {return _storage._encryption}
    set {_uniqueStorage()._encryption = newValue}
  }

  var stream: String {
    get {return _storage._stream}
    set {_uniqueStorage()._stream = newValue}
  }

  var version: Livekit_TimedVersion {
    get {return _storage._version ?? Livekit_TimedVersion()}
    set {_uniqueStorage()._version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return _storage._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {_uniqueStorage()._version = nil}

  var audioFeatures: [Livekit_AudioTrackFeature] {
    get {return _storage._audioFeatures}
    set {_uniqueStorage()._audioFeatures = newValue}
  }

  var backupCodecPolicy: Livekit_BackupCodecPolicy {
    get {return _storage._backupCodecPolicy}
    set {_uniqueStorage()._backupCodecPolicy = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// provide information about available spatial layers
struct Livekit_VideoLayer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// for tracks with a single layer, this should be HIGH
  var quality: Livekit_VideoQuality = .low

  var width: UInt32 = 0

  var height: UInt32 = 0

  /// target bitrate in bit per second (bps), server will measure actual
  var bitrate: UInt32 = 0

  var ssrc: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// new DataPacket API
struct Livekit_DataPacket: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NOTE: This field was marked as deprecated in the .proto file.
  var kind: Livekit_DataPacket.Kind {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// participant identity of user that sent the message
  var participantIdentity: String {
    get {return _storage._participantIdentity}
    set {_uniqueStorage()._participantIdentity = newValue}
  }

  /// identities of participants who will receive the message (sent to all by default)
  var destinationIdentities: [String] {
    get {return _storage._destinationIdentities}
    set {_uniqueStorage()._destinationIdentities = newValue}
  }

  var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  var user: Livekit_UserPacket {
    get {
      if case .user(let v)? = _storage._value {return v}
      return Livekit_UserPacket()
    }
    set {_uniqueStorage()._value = .user(newValue)}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var speaker: Livekit_ActiveSpeakerUpdate {
    get {
      if case .speaker(let v)? = _storage._value {return v}
      return Livekit_ActiveSpeakerUpdate()
    }
    set {_uniqueStorage()._value = .speaker(newValue)}
  }

  var sipDtmf: Livekit_SipDTMF {
    get {
      if case .sipDtmf(let v)? = _storage._value {return v}
      return Livekit_SipDTMF()
    }
    set {_uniqueStorage()._value = .sipDtmf(newValue)}
  }

  var transcription: Livekit_Transcription {
    get {
      if case .transcription(let v)? = _storage._value {return v}
      return Livekit_Transcription()
    }
    set {_uniqueStorage()._value = .transcription(newValue)}
  }

  var metrics: Livekit_MetricsBatch {
    get {
      if case .metrics(let v)? = _storage._value {return v}
      return Livekit_MetricsBatch()
    }
    set {_uniqueStorage()._value = .metrics(newValue)}
  }

  var chatMessage: Livekit_ChatMessage {
    get {
      if case .chatMessage(let v)? = _storage._value {return v}
      return Livekit_ChatMessage()
    }
    set {_uniqueStorage()._value = .chatMessage(newValue)}
  }

  var rpcRequest: Livekit_RpcRequest {
    get {
      if case .rpcRequest(let v)? = _storage._value {return v}
      return Livekit_RpcRequest()
    }
    set {_uniqueStorage()._value = .rpcRequest(newValue)}
  }

  var rpcAck: Livekit_RpcAck {
    get {
      if case .rpcAck(let v)? = _storage._value {return v}
      return Livekit_RpcAck()
    }
    set {_uniqueStorage()._value = .rpcAck(newValue)}
  }

  var rpcResponse: Livekit_RpcResponse {
    get {
      if case .rpcResponse(let v)? = _storage._value {return v}
      return Livekit_RpcResponse()
    }
    set {_uniqueStorage()._value = .rpcResponse(newValue)}
  }

  var streamHeader: Livekit_DataStream.Header {
    get {
      if case .streamHeader(let v)? = _storage._value {return v}
      return Livekit_DataStream.Header()
    }
    set {_uniqueStorage()._value = .streamHeader(newValue)}
  }

  var streamChunk: Livekit_DataStream.Chunk {
    get {
      if case .streamChunk(let v)? = _storage._value {return v}
      return Livekit_DataStream.Chunk()
    }
    set {_uniqueStorage()._value = .streamChunk(newValue)}
  }

  var streamTrailer: Livekit_DataStream.Trailer {
    get {
      if case .streamTrailer(let v)? = _storage._value {return v}
      return Livekit_DataStream.Trailer()
    }
    set {_uniqueStorage()._value = .streamTrailer(newValue)}
  }

  /// sequence number of reliable packet
  var sequence: UInt32 {
    get {return _storage._sequence}
    set {_uniqueStorage()._sequence = newValue}
  }

  /// sid of the user that sent the message
  var participantSid: String {
    get {return _storage._participantSid}
    set {_uniqueStorage()._participantSid = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable, Sendable {
    case user(Livekit_UserPacket)
    /// NOTE: This field was marked as deprecated in the .proto file.
    case speaker(Livekit_ActiveSpeakerUpdate)
    case sipDtmf(Livekit_SipDTMF)
    case transcription(Livekit_Transcription)
    case metrics(Livekit_MetricsBatch)
    case chatMessage(Livekit_ChatMessage)
    case rpcRequest(Livekit_RpcRequest)
    case rpcAck(Livekit_RpcAck)
    case rpcResponse(Livekit_RpcResponse)
    case streamHeader(Livekit_DataStream.Header)
    case streamChunk(Livekit_DataStream.Chunk)
    case streamTrailer(Livekit_DataStream.Trailer)

  }

  enum Kind: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case reliable // = 0
    case lossy // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .reliable
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .reliable
      case 1: self = .lossy
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .reliable: return 0
      case .lossy: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Livekit_DataPacket.Kind] = [
      .reliable,
      .lossy,
    ]

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Livekit_ActiveSpeakerUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var speakers: [Livekit_SpeakerInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_SpeakerInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sid: String = String()

  /// audio level, 0-1.0, 1 is loudest
  var level: Float = 0

  /// true if speaker is currently active
  var active: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_UserPacket: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// participant ID of user that sent the message
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var participantSid: String = String()

  /// NOTE: This field was marked as deprecated in the .proto file.
  var participantIdentity: String = String()

  /// user defined payload
  var payload: Data = Data()

  /// the ID of the participants who will receive the message (sent to all by default)
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var destinationSids: [String] = []

  /// identities of participants who will receive the message (sent to all by default)
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var destinationIdentities: [String] = []

  /// topic under which the message was published
  var topic: String {
    get {return _topic ?? String()}
    set {_topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  var hasTopic: Bool {return self._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  mutating func clearTopic() {self._topic = nil}

  /// Unique ID to indentify the message
  var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// start and end time allow relating the message to specific media time
  var startTime: UInt64 {
    get {return _startTime ?? 0}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {self._startTime = nil}

  var endTime: UInt64 {
    get {return _endTime ?? 0}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {self._endTime = nil}

  /// added by SDK to enable de-duping of messages, for INTERNAL USE ONLY
  var nonce: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _topic: String? = nil
  fileprivate var _id: String? = nil
  fileprivate var _startTime: UInt64? = nil
  fileprivate var _endTime: UInt64? = nil
}

struct Livekit_SipDTMF: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: UInt32 = 0

  var digit: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_Transcription: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Participant that got its speech transcribed
  var transcribedParticipantIdentity: String = String()

  var trackID: String = String()

  var segments: [Livekit_TranscriptionSegment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_TranscriptionSegment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var text: String = String()

  var startTime: UInt64 = 0

  var endTime: UInt64 = 0

  var final: Bool = false

  var language: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_ChatMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// uuid
  var id: String = String()

  var timestamp: Int64 = 0

  /// populated only if the intent is to edit/update an existing message
  var editTimestamp: Int64 {
    get {return _editTimestamp ?? 0}
    set {_editTimestamp = newValue}
  }
  /// Returns true if `editTimestamp` has been explicitly set.
  var hasEditTimestamp: Bool {return self._editTimestamp != nil}
  /// Clears the value of `editTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearEditTimestamp() {self._editTimestamp = nil}

  var message: String = String()

  /// true to remove message
  var deleted: Bool = false

  /// true if the chat message has been generated by an agent from a participant's audio transcription
  var generated: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _editTimestamp: Int64? = nil
}

struct Livekit_RpcRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var method: String = String()

  var payload: String = String()

  var responseTimeoutMs: UInt32 = 0

  var version: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_RpcAck: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_RpcResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var value: Livekit_RpcResponse.OneOf_Value? = nil

  var payload: String {
    get {
      if case .payload(let v)? = value {return v}
      return String()
    }
    set {value = .payload(newValue)}
  }

  var error: Livekit_RpcError {
    get {
      if case .error(let v)? = value {return v}
      return Livekit_RpcError()
    }
    set {value = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable, Sendable {
    case payload(String)
    case error(Livekit_RpcError)

  }

  init() {}
}

struct Livekit_RpcError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: UInt32 = 0

  var message: String = String()

  var data: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_ParticipantTracks: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// participant ID of participant to whom the tracks belong
  var participantSid: String = String()

  var trackSids: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// details about the server
struct Livekit_ServerInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var edition: Livekit_ServerInfo.Edition = .standard

  var version: String = String()

  var `protocol`: Int32 = 0

  var region: String = String()

  var nodeID: String = String()

  /// additional debugging information. sent only if server is in development mode
  var debugInfo: String = String()

  var agentProtocol: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Edition: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case standard // = 0
    case cloud // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .standard
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .standard
      case 1: self = .cloud
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .standard: return 0
      case .cloud: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Livekit_ServerInfo.Edition] = [
      .standard,
      .cloud,
    ]

  }

  init() {}
}

/// details about the client
struct Livekit_ClientInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sdk: Livekit_ClientInfo.SDK = .unknown

  var version: String = String()

  var `protocol`: Int32 = 0

  var os: String = String()

  var osVersion: String = String()

  var deviceModel: String = String()

  var browser: String = String()

  var browserVersion: String = String()

  var address: String = String()

  /// wifi, wired, cellular, vpn, empty if not known
  var network: String = String()

  /// comma separated list of additional LiveKit SDKs in use of this client, with versions
  /// e.g. "components-js:1.2.3,track-processors-js:1.2.3"
  var otherSdks: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum SDK: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case js // = 1
    case swift // = 2
    case android // = 3
    case flutter // = 4
    case go // = 5
    case unity // = 6
    case reactNative // = 7
    case rust // = 8
    case python // = 9
    case cpp // = 10
    case unityWeb // = 11
    case node // = 12
    case unreal // = 13
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .js
      case 2: self = .swift
      case 3: self = .android
      case 4: self = .flutter
      case 5: self = .go
      case 6: self = .unity
      case 7: self = .reactNative
      case 8: self = .rust
      case 9: self = .python
      case 10: self = .cpp
      case 11: self = .unityWeb
      case 12: self = .node
      case 13: self = .unreal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .js: return 1
      case .swift: return 2
      case .android: return 3
      case .flutter: return 4
      case .go: return 5
      case .unity: return 6
      case .reactNative: return 7
      case .rust: return 8
      case .python: return 9
      case .cpp: return 10
      case .unityWeb: return 11
      case .node: return 12
      case .unreal: return 13
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Livekit_ClientInfo.SDK] = [
      .unknown,
      .js,
      .swift,
      .android,
      .flutter,
      .go,
      .unity,
      .reactNative,
      .rust,
      .python,
      .cpp,
      .unityWeb,
      .node,
      .unreal,
    ]

  }

  init() {}
}

/// server provided client configuration
struct Livekit_ClientConfiguration: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var video: Livekit_VideoConfiguration {
    get {return _video ?? Livekit_VideoConfiguration()}
    set {_video = newValue}
  }
  /// Returns true if `video` has been explicitly set.
  var hasVideo: Bool {return self._video != nil}
  /// Clears the value of `video`. Subsequent reads from it will return its default value.
  mutating func clearVideo() {self._video = nil}

  var screen: Livekit_VideoConfiguration {
    get {return _screen ?? Livekit_VideoConfiguration()}
    set {_screen = newValue}
  }
  /// Returns true if `screen` has been explicitly set.
  var hasScreen: Bool {return self._screen != nil}
  /// Clears the value of `screen`. Subsequent reads from it will return its default value.
  mutating func clearScreen() {self._screen = nil}

  var resumeConnection: Livekit_ClientConfigSetting = .unset

  var disabledCodecs: Livekit_DisabledCodecs {
    get {return _disabledCodecs ?? Livekit_DisabledCodecs()}
    set {_disabledCodecs = newValue}
  }
  /// Returns true if `disabledCodecs` has been explicitly set.
  var hasDisabledCodecs: Bool {return self._disabledCodecs != nil}
  /// Clears the value of `disabledCodecs`. Subsequent reads from it will return its default value.
  mutating func clearDisabledCodecs() {self._disabledCodecs = nil}

  var forceRelay: Livekit_ClientConfigSetting = .unset

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _video: Livekit_VideoConfiguration? = nil
  fileprivate var _screen: Livekit_VideoConfiguration? = nil
  fileprivate var _disabledCodecs: Livekit_DisabledCodecs? = nil
}

struct Livekit_VideoConfiguration: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hardwareEncoder: Livekit_ClientConfigSetting = .unset

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_DisabledCodecs: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// disabled for both publish and subscribe
  var codecs: [Livekit_Codec] = []

  /// only disable for publish
  var publish: [Livekit_Codec] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_RTPDrift: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {self._startTime = nil}

  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {self._endTime = nil}

  var duration: Double = 0

  var startTimestamp: UInt64 = 0

  var endTimestamp: UInt64 = 0

  var rtpClockTicks: UInt64 = 0

  var driftSamples: Int64 = 0

  var driftMs: Double = 0

  var clockRate: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Livekit_RTPStats: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  var duration: Double {
    get {return _storage._duration}
    set {_uniqueStorage()._duration = newValue}
  }

  var packets: UInt32 {
    get {return _storage._packets}
    set {_uniqueStorage()._packets = newValue}
  }

  var packetRate: Double {
    get {return _storage._packetRate}
    set {_uniqueStorage()._packetRate = newValue}
  }

  var bytes: UInt64 {
    get {return _storage._bytes}
    set {_uniqueStorage()._bytes = newValue}
  }

  var headerBytes: UInt64 {
    get {return _storage._headerBytes}
    set {_uniqueStorage()._headerBytes = newValue}
  }

  var bitrate: Double {
    get {return _storage._bitrate}
    set {_uniqueStorage()._bitrate = newValue}
  }

  var packetsLost: UInt32 {
    get {return _storage._packetsLost}
    set {_uniqueStorage()._packetsLost = newValue}
  }

  var packetLossRate: Double {
    get {return _storage._packetLossRate}
    set {_uniqueStorage()._packetLossRate = newValue}
  }

  var packetLossPercentage: Float {
    get {return _storage._packetLossPercentage}
    set {_uniqueStorage()._packetLossPercentage = newValue}
  }

  var packetsDuplicate: UInt32 {
    get {return _storage._packetsDuplicate}
    set {_uniqueStorage()._packetsDuplicate = newValue}
  }

  var packetDuplicateRate: Double {
    get {return _storage._packetDuplicateRate}
    set {_uniqueStorage()._packetDuplicateRate = newValue}
  }

  var bytesDuplicate: UInt64 {
    get {return _storage._bytesDuplicate}
    set {_uniqueStorage()._bytesDuplicate = newValue}
  }

  var headerBytesDuplicate: UInt64 {
    get {return _storage._headerBytesDuplicate}
    set {_uniqueStorage()._headerBytesDuplicate = newValue}
  }

  var bitrateDuplicate: Double {
    get {return _storage._bitrateDuplicate}
    set {_uniqueStorage()._bitrateDuplicate = newValue}
  }

  var packetsPadding: UInt32 {
    get {return _storage._packetsPadding}
    set {_uniqueStorage()._packetsPadding = newValue}
  }

  var packetPaddingRate: Double {
    get {return _storage._packetPaddingRate}
    set {_uniqueStorage()._packetPaddingRate = newValue}
  }

  var bytesPadding: UInt64 {
    get {return _storage._bytesPadding}
    set {_uniqueStorage()._bytesPadding = newValue}
  }

  var headerBytesPadding: UInt64 {
    get {return _storage._headerBytesPadding}
    set {_uniqueStorage()._headerBytesPadding = newValue}
  }

  var bitratePadding: Double {
    get {return _storage._bitratePadding}
    set {_uniqueStorage()._bitratePadding = newValue}
  }

  var packetsOutOfOrder: UInt32 {
    get {return _storage._packetsOutOfOrder}
    set {_uniqueStorage()._packetsOutOfOrder = newValue}
  }

  var frames: UInt32 {
    get {return _storage._frames}
    set {_uniqueStorage()._frames = newValue}
  }

  var frameRate: Double {
    get {return _storage._frameRate}
    set {_uniqueStorage()._frameRate = newValue}
  }

  var jitterCurrent: Double {
    get {return _storage._jitterCurrent}
    set {_uniqueStorage()._jitterCurrent = newValue}
  }

  var jitterMax: Double {
    get {return _storage._jitterMax}
    set {_uniqueStorage()._jitterMax = newValue}
  }

  var gapHistogram: Dictionary<Int32,UInt32> {
    get {return _storage._gapHistogram}
    set {_uniqueStorage()._gapHistogram = newValue}
  }

  var nacks: UInt32 {
    get {return _storage._nacks}
    set {_uniqueStorage()._nacks = newValue}
  }

  var nackAcks: UInt32 {
    get {return _storage._nackAcks}
    set {_uniqueStorage()._nackAcks = newValue}
  }

  var nackMisses: UInt32 {
    get {return _storage._nackMisses}
    set {_uniqueStorage()._nackMisses = newValue}
  }

  var nackRepeated: UInt32 {
    get {return _storage._nackRepeated}
    set {_uniqueStorage()._nackRepeated = newValue}
  }

  var plis: UInt32 {
    get {return _storage._plis}
    set {_uniqueStorage()._plis = newValue}
  }

  var lastPli: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastPli ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastPli = newValue}
  }
  /// Returns true if `lastPli` has been explicitly set.
  var hasLastPli: Bool {return _storage._lastPli != nil}
  /// Clears the value of `lastPli`. Subsequent reads from it will return its default value.
  mutating func clearLastPli() {_uniqueStorage()._lastPli = nil}

  var firs: UInt32 {
    get {return _storage._firs}
    set {_uniqueStorage()._firs = newValue}
  }

  var lastFir: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastFir ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastFir = newValue}
  }
  /// Returns true if `lastFir` has been explicitly set.
  var hasLastFir: Bool {return _storage._lastFir != nil}
  /// Clears the value of `lastFir`. Subsequent reads from it will return its default value.
  mutating func clearLastFir() {_uniqueStorage()._lastFir = nil}

  var rttCurrent: UInt32 {
    get {return _storage._rttCurrent}
    set {_uniqueStorage()._rttCurrent = newValue}
  }

  var rttMax: UInt32 {
    get {return _storage._rttMax}
    set {_uniqueStorage()._rttMax = newValue}
  }

  var keyFrames: UInt32 {
    get {return _storage._keyFrames}
    set {_uniqueStorage()._keyFrames = newValue}
  }

  var lastKeyFrame: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastKeyFrame ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastKeyFrame = newValue}
  }
  /// Returns true if `lastKeyFrame` has been explicitly set.
  var hasLastKeyFrame: Bool {return _storage._lastKeyFrame != nil}
  /// Clears the value of `lastKeyFrame`. Subsequent reads from it will return its default value.
  mutating func clearLastKeyFrame() {_uniqueStorage()._lastKeyFrame = nil}

  var layerLockPlis: UInt32 {
    get {return _storage._layerLockPlis}
    set {_uniqueStorage()._layerLockPlis = newValue}
  }

  var lastLayerLockPli: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastLayerLockPli ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastLayerLockPli = newValue}
  }
  /// Returns true if `lastLayerLockPli` has been explicitly set.
  var hasLastLayerLockPli: Bool {return _storage._lastLayerLockPli != nil}
  /// Clears the value of `lastLayerLockPli`. Subsequent reads from it will return its default value.
  mutating func clearLastLayerLockPli() {_uniqueStorage()._lastLayerLockPli = nil}

  var packetDrift: Livekit_RTPDrift {
    get {return _storage._packetDrift ?? Livekit_RTPDrift()}
    set {_uniqueStorage()._packetDrift = newValue}
  }
  /// Returns true if `packetDrift` has been explicitly set.
  var hasPacketDrift: Bool {return _storage._packetDrift != nil}
  /// Clears the value of `packetDrift`. Subsequent reads from it will return its default value.
  mutating func clearPacketDrift() {_uniqueStorage()._packetDrift = nil}

  var ntpReportDrift: Livekit_RTPDrift {
    get {return _storage._ntpReportDrift ?? Livekit_RTPDrift()}
    set {_uniqueStorage()._ntpReportDrift = newValue}
  }
  /// Returns true if `ntpReportDrift` has been explicitly set.
  var hasNtpReportDrift: Bool {return _storage._ntpReportDrift != nil}
  /// Clears the value of `ntpReportDrift`. Subsequent reads from it will return its default value.
  mutating func clearNtpReportDrift() {_uniqueStorage()._ntpReportDrift = nil}

  var rebasedReportDrift: Livekit_RTPDrift {
    get {return _storage._rebasedReportDrift ?? Livekit_RTPDrift()}
    set {_uniqueStorage()._rebasedReportDrift = newValue}
  }
  /// Returns true if `rebasedReportDrift` has been explicitly set.
  var hasRebasedReportDrift: Bool {return _storage._rebasedReportDrift != nil}
  /// Clears the value of `rebasedReportDrift`. Subsequent reads from it will return its default value.
  mutating func clearRebasedReportDrift() {_uniqueStorage()._rebasedReportDrift = nil}

  /// NEXT_ID: 48
  var receivedReportDrift: Livekit_RTPDrift {
    get {return _storage._receivedReportDrift ?? Livekit_RTPDrift()}
    set {_uniqueStorage()._receivedReportDrift = newValue}
  }
  /// Returns true if `receivedReportDrift` has been explicitly set.
  var hasReceivedReportDrift: Bool {return _storage._receivedReportDrift != nil}
  /// Clears the value of `receivedReportDrift`. Subsequent reads from it will return its default value.
  mutating func clearReceivedReportDrift() {_uniqueStorage()._receivedReportDrift = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Livekit_RTCPSenderReportState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rtpTimestamp: UInt32 = 0

  var rtpTimestampExt: UInt64 = 0

  var ntpTimestamp: UInt64 = 0

  /// time at which this happened
  var at: Int64 = 0

  var atAdjusted: Int64 = 0

  var packets: UInt32 = 0

  var octets: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_RTPForwarderState: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var started: Bool {
    get {return _storage._started}
    set {_uniqueStorage()._started = newValue}
  }

  var referenceLayerSpatial: Int32 {
    get {return _storage._referenceLayerSpatial}
    set {_uniqueStorage()._referenceLayerSpatial = newValue}
  }

  var preStartTime: Int64 {
    get {return _storage._preStartTime}
    set {_uniqueStorage()._preStartTime = newValue}
  }

  var extFirstTimestamp: UInt64 {
    get {return _storage._extFirstTimestamp}
    set {_uniqueStorage()._extFirstTimestamp = newValue}
  }

  var dummyStartTimestampOffset: UInt64 {
    get {return _storage._dummyStartTimestampOffset}
    set {_uniqueStorage()._dummyStartTimestampOffset = newValue}
  }

  var rtpMunger: Livekit_RTPMungerState {
    get {return _storage._rtpMunger ?? Livekit_RTPMungerState()}
    set {_uniqueStorage()._rtpMunger = newValue}
  }
  /// Returns true if `rtpMunger` has been explicitly set.
  var hasRtpMunger: Bool {return _storage._rtpMunger != nil}
  /// Clears the value of `rtpMunger`. Subsequent reads from it will return its default value.
  mutating func clearRtpMunger() {_uniqueStorage()._rtpMunger = nil}

  var codecMunger: OneOf_CodecMunger? {
    get {return _storage._codecMunger}
    set {_uniqueStorage()._codecMunger = newValue}
  }

  var vp8Munger: Livekit_VP8MungerState {
    get {
      if case .vp8Munger(let v)? = _storage._codecMunger {return v}
      return Livekit_VP8MungerState()
    }
    set {_uniqueStorage()._codecMunger = .vp8Munger(newValue)}
  }

  var senderReportState: [Livekit_RTCPSenderReportState] {
    get {return _storage._senderReportState}
    set {_uniqueStorage()._senderReportState = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_CodecMunger: Equatable, Sendable {
    case vp8Munger(Livekit_VP8MungerState)

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Livekit_RTPMungerState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var extLastSequenceNumber: UInt64 = 0

  var extSecondLastSequenceNumber: UInt64 = 0

  var extLastTimestamp: UInt64 = 0

  var extSecondLastTimestamp: UInt64 = 0

  var lastMarker: Bool = false

  var secondLastMarker: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_VP8MungerState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var extLastPictureID: Int32 = 0

  var pictureIDUsed: Bool = false

  var lastTl0PicIdx: UInt32 = 0

  var tl0PicIdxUsed: Bool = false

  var tidUsed: Bool = false

  var lastKeyIdx: UInt32 = 0

  var keyIdxUsed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_TimedVersion: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unixMicro: Int64 = 0

  var ticks: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Livekit_DataStream: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// enum for operation types (specific to TextHeader)
  enum OperationType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case create // = 0
    case update // = 1
    case delete // = 2
    case reaction // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .create
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .create
      case 1: self = .update
      case 2: self = .delete
      case 3: self = .reaction
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .create: return 0
      case .update: return 1
      case .delete: return 2
      case .reaction: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Livekit_DataStream.OperationType] = [
      .create,
      .update,
      .delete,
      .reaction,
    ]

  }

  /// header properties specific to text streams
  struct TextHeader: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var operationType: Livekit_DataStream.OperationType = .create

    /// Optional: Version for updates/edits
    var version: Int32 = 0

    /// Optional: Reply to specific message
    var replyToStreamID: String = String()

    /// file attachments for text streams
    var attachedStreamIds: [String] = []

    /// true if the text has been generated by an agent from a participant's audio transcription
    var generated: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// header properties specific to byte or file streams
  struct ByteHeader: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// main DataStream.Header that contains a oneof for specific headers
  struct Header: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// unique identifier for this data stream
    var streamID: String = String()

    /// using int64 for Unix timestamp
    var timestamp: Int64 = 0

    var topic: String = String()

    var mimeType: String = String()

    /// only populated for finite streams, if it's a stream of unknown size this stays empty
    var totalLength: UInt64 {
      get {return _totalLength ?? 0}
      set {_totalLength = newValue}
    }
    /// Returns true if `totalLength` has been explicitly set.
    var hasTotalLength: Bool {return self._totalLength != nil}
    /// Clears the value of `totalLength`. Subsequent reads from it will return its default value.
    mutating func clearTotalLength() {self._totalLength = nil}

    /// defaults to NONE
    var encryptionType: Livekit_Encryption.TypeEnum = .none

    /// user defined attributes map that can carry additional info
    var attributes: Dictionary<String,String> = [:]

    /// oneof to choose between specific header types
    var contentHeader: Livekit_DataStream.Header.OneOf_ContentHeader? = nil

    var textHeader: Livekit_DataStream.TextHeader {
      get {
        if case .textHeader(let v)? = contentHeader {return v}
        return Livekit_DataStream.TextHeader()
      }
      set {contentHeader = .textHeader(newValue)}
    }

    var byteHeader: Livekit_DataStream.ByteHeader {
      get {
        if case .byteHeader(let v)? = contentHeader {return v}
        return Livekit_DataStream.ByteHeader()
      }
      set {contentHeader = .byteHeader(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// oneof to choose between specific header types
    enum OneOf_ContentHeader: Equatable, Sendable {
      case textHeader(Livekit_DataStream.TextHeader)
      case byteHeader(Livekit_DataStream.ByteHeader)

    }

    init() {}

    fileprivate var _totalLength: UInt64? = nil
  }

  struct Chunk: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// unique identifier for this data stream to map it to the correct header
    var streamID: String = String()

    var chunkIndex: UInt64 = 0

    /// content as binary (bytes)
    var content: Data = Data()

    /// a version indicating that this chunk_index has been retroactively modified and the original one needs to be replaced
    var version: Int32 = 0

    /// optional, initialization vector for AES-GCM encryption
    var iv: Data {
      get {return _iv ?? Data()}
      set {_iv = newValue}
    }
    /// Returns true if `iv` has been explicitly set.
    var hasIv: Bool {return self._iv != nil}
    /// Clears the value of `iv`. Subsequent reads from it will return its default value.
    mutating func clearIv() {self._iv = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _iv: Data? = nil
  }

  struct Trailer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// unique identifier for this data stream
    var streamID: String = String()

    /// reason why the stream was closed (could contain "error" / "interrupted" / empty for expected end)
    var reason: String = String()

    /// finalizing updates for the stream, can also include additional insights for errors or endTime for transcription
    var attributes: Dictionary<String,String> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Livekit_WebhookConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String = String()

  var signingKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "livekit"

extension Livekit_AudioCodec: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT_AC"),
    1: .same(proto: "OPUS"),
    2: .same(proto: "AAC"),
  ]
}

extension Livekit_VideoCodec: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT_VC"),
    1: .same(proto: "H264_BASELINE"),
    2: .same(proto: "H264_MAIN"),
    3: .same(proto: "H264_HIGH"),
    4: .same(proto: "VP8"),
  ]
}

extension Livekit_ImageCodec: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IC_DEFAULT"),
    1: .same(proto: "IC_JPEG"),
  ]
}

extension Livekit_BackupCodecPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PREFER_REGRESSION"),
    1: .same(proto: "SIMULCAST"),
    2: .same(proto: "REGRESSION"),
  ]
}

extension Livekit_TrackType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUDIO"),
    1: .same(proto: "VIDEO"),
    2: .same(proto: "DATA"),
  ]
}

extension Livekit_TrackSource: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CAMERA"),
    2: .same(proto: "MICROPHONE"),
    3: .same(proto: "SCREEN_SHARE"),
    4: .same(proto: "SCREEN_SHARE_AUDIO"),
  ]
}

extension Livekit_VideoQuality: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOW"),
    1: .same(proto: "MEDIUM"),
    2: .same(proto: "HIGH"),
    3: .same(proto: "OFF"),
  ]
}

extension Livekit_ConnectionQuality: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POOR"),
    1: .same(proto: "GOOD"),
    2: .same(proto: "EXCELLENT"),
    3: .same(proto: "LOST"),
  ]
}

extension Livekit_ClientConfigSetting: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "DISABLED"),
    2: .same(proto: "ENABLED"),
  ]
}

extension Livekit_DisconnectReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "CLIENT_INITIATED"),
    2: .same(proto: "DUPLICATE_IDENTITY"),
    3: .same(proto: "SERVER_SHUTDOWN"),
    4: .same(proto: "PARTICIPANT_REMOVED"),
    5: .same(proto: "ROOM_DELETED"),
    6: .same(proto: "STATE_MISMATCH"),
    7: .same(proto: "JOIN_FAILURE"),
    8: .same(proto: "MIGRATION"),
    9: .same(proto: "SIGNAL_CLOSE"),
    10: .same(proto: "ROOM_CLOSED"),
    11: .same(proto: "USER_UNAVAILABLE"),
    12: .same(proto: "USER_REJECTED"),
    13: .same(proto: "SIP_TRUNK_FAILURE"),
    14: .same(proto: "CONNECTION_TIMEOUT"),
    15: .same(proto: "MEDIA_FAILURE"),
  ]
}

extension Livekit_ReconnectReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RR_UNKNOWN"),
    1: .same(proto: "RR_SIGNAL_DISCONNECTED"),
    2: .same(proto: "RR_PUBLISHER_FAILED"),
    3: .same(proto: "RR_SUBSCRIBER_FAILED"),
    4: .same(proto: "RR_SWITCH_CANDIDATE"),
  ]
}

extension Livekit_SubscriptionError: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SE_UNKNOWN"),
    1: .same(proto: "SE_CODEC_UNSUPPORTED"),
    2: .same(proto: "SE_TRACK_NOTFOUND"),
  ]
}

extension Livekit_AudioTrackFeature: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TF_STEREO"),
    1: .same(proto: "TF_NO_DTX"),
    2: .same(proto: "TF_AUTO_GAIN_CONTROL"),
    3: .same(proto: "TF_ECHO_CANCELLATION"),
    4: .same(proto: "TF_NOISE_SUPPRESSION"),
    5: .same(proto: "TF_ENHANCED_NOISE_CANCELLATION"),
    6: .same(proto: "TF_PRECONNECT_BUFFER"),
  ]
}

extension Livekit_Pagination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pagination"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "after_id"),
    2: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.afterID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.afterID.isEmpty {
      try visitor.visitSingularStringField(value: self.afterID, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_Pagination, rhs: Livekit_Pagination) -> Bool {
    if lhs.afterID != rhs.afterID {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_ListUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.set) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.set.isEmpty {
      try visitor.visitRepeatedStringField(value: self.set, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_ListUpdate, rhs: Livekit_ListUpdate) -> Bool {
    if lhs.set != rhs.set {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_Room: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Room"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sid"),
    2: .same(proto: "name"),
    3: .standard(proto: "empty_timeout"),
    14: .standard(proto: "departure_timeout"),
    4: .standard(proto: "max_participants"),
    5: .standard(proto: "creation_time"),
    15: .standard(proto: "creation_time_ms"),
    6: .standard(proto: "turn_password"),
    7: .standard(proto: "enabled_codecs"),
    8: .same(proto: "metadata"),
    9: .standard(proto: "num_participants"),
    11: .standard(proto: "num_publishers"),
    10: .standard(proto: "active_recording"),
    13: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.emptyTimeout) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.maxParticipants) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.creationTime) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.turnPassword) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.enabledCodecs) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.numParticipants) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.activeRecording) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.numPublishers) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      case 14: try { try decoder.decodeSingularUInt32Field(value: &self.departureTimeout) }()
      case 15: try { try decoder.decodeSingularInt64Field(value: &self.creationTimeMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sid.isEmpty {
      try visitor.visitSingularStringField(value: self.sid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.emptyTimeout != 0 {
      try visitor.visitSingularUInt32Field(value: self.emptyTimeout, fieldNumber: 3)
    }
    if self.maxParticipants != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxParticipants, fieldNumber: 4)
    }
    if self.creationTime != 0 {
      try visitor.visitSingularInt64Field(value: self.creationTime, fieldNumber: 5)
    }
    if !self.turnPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.turnPassword, fieldNumber: 6)
    }
    if !self.enabledCodecs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.enabledCodecs, fieldNumber: 7)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 8)
    }
    if self.numParticipants != 0 {
      try visitor.visitSingularUInt32Field(value: self.numParticipants, fieldNumber: 9)
    }
    if self.activeRecording != false {
      try visitor.visitSingularBoolField(value: self.activeRecording, fieldNumber: 10)
    }
    if self.numPublishers != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPublishers, fieldNumber: 11)
    }
    try { if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    if self.departureTimeout != 0 {
      try visitor.visitSingularUInt32Field(value: self.departureTimeout, fieldNumber: 14)
    }
    if self.creationTimeMs != 0 {
      try visitor.visitSingularInt64Field(value: self.creationTimeMs, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_Room, rhs: Livekit_Room) -> Bool {
    if lhs.sid != rhs.sid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.emptyTimeout != rhs.emptyTimeout {return false}
    if lhs.departureTimeout != rhs.departureTimeout {return false}
    if lhs.maxParticipants != rhs.maxParticipants {return false}
    if lhs.creationTime != rhs.creationTime {return false}
    if lhs.creationTimeMs != rhs.creationTimeMs {return false}
    if lhs.turnPassword != rhs.turnPassword {return false}
    if lhs.enabledCodecs != rhs.enabledCodecs {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.numParticipants != rhs.numParticipants {return false}
    if lhs.numPublishers != rhs.numPublishers {return false}
    if lhs.activeRecording != rhs.activeRecording {return false}
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_Codec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Codec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mime"),
    2: .standard(proto: "fmtp_line"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mime) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fmtpLine) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mime.isEmpty {
      try visitor.visitSingularStringField(value: self.mime, fieldNumber: 1)
    }
    if !self.fmtpLine.isEmpty {
      try visitor.visitSingularStringField(value: self.fmtpLine, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_Codec, rhs: Livekit_Codec) -> Bool {
    if lhs.mime != rhs.mime {return false}
    if lhs.fmtpLine != rhs.fmtpLine {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_PlayoutDelay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayoutDelay"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "min"),
    3: .same(proto: "max"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.min) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.max) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.min != 0 {
      try visitor.visitSingularUInt32Field(value: self.min, fieldNumber: 2)
    }
    if self.max != 0 {
      try visitor.visitSingularUInt32Field(value: self.max, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_PlayoutDelay, rhs: Livekit_PlayoutDelay) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_ParticipantPermission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantPermission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_subscribe"),
    2: .standard(proto: "can_publish"),
    3: .standard(proto: "can_publish_data"),
    9: .standard(proto: "can_publish_sources"),
    7: .same(proto: "hidden"),
    8: .same(proto: "recorder"),
    10: .standard(proto: "can_update_metadata"),
    11: .same(proto: "agent"),
    12: .standard(proto: "can_subscribe_metrics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canSubscribe) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canPublish) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canPublishData) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.hidden) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.recorder) }()
      case 9: try { try decoder.decodeRepeatedEnumField(value: &self.canPublishSources) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.canUpdateMetadata) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.agent) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.canSubscribeMetrics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canSubscribe != false {
      try visitor.visitSingularBoolField(value: self.canSubscribe, fieldNumber: 1)
    }
    if self.canPublish != false {
      try visitor.visitSingularBoolField(value: self.canPublish, fieldNumber: 2)
    }
    if self.canPublishData != false {
      try visitor.visitSingularBoolField(value: self.canPublishData, fieldNumber: 3)
    }
    if self.hidden != false {
      try visitor.visitSingularBoolField(value: self.hidden, fieldNumber: 7)
    }
    if self.recorder != false {
      try visitor.visitSingularBoolField(value: self.recorder, fieldNumber: 8)
    }
    if !self.canPublishSources.isEmpty {
      try visitor.visitPackedEnumField(value: self.canPublishSources, fieldNumber: 9)
    }
    if self.canUpdateMetadata != false {
      try visitor.visitSingularBoolField(value: self.canUpdateMetadata, fieldNumber: 10)
    }
    if self.agent != false {
      try visitor.visitSingularBoolField(value: self.agent, fieldNumber: 11)
    }
    if self.canSubscribeMetrics != false {
      try visitor.visitSingularBoolField(value: self.canSubscribeMetrics, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_ParticipantPermission, rhs: Livekit_ParticipantPermission) -> Bool {
    if lhs.canSubscribe != rhs.canSubscribe {return false}
    if lhs.canPublish != rhs.canPublish {return false}
    if lhs.canPublishData != rhs.canPublishData {return false}
    if lhs.canPublishSources != rhs.canPublishSources {return false}
    if lhs.hidden != rhs.hidden {return false}
    if lhs.recorder != rhs.recorder {return false}
    if lhs.canUpdateMetadata != rhs.canUpdateMetadata {return false}
    if lhs.agent != rhs.agent {return false}
    if lhs.canSubscribeMetrics != rhs.canSubscribeMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_ParticipantInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sid"),
    2: .same(proto: "identity"),
    3: .same(proto: "state"),
    4: .same(proto: "tracks"),
    5: .same(proto: "metadata"),
    6: .standard(proto: "joined_at"),
    17: .standard(proto: "joined_at_ms"),
    9: .same(proto: "name"),
    10: .same(proto: "version"),
    11: .same(proto: "permission"),
    12: .same(proto: "region"),
    13: .standard(proto: "is_publisher"),
    14: .same(proto: "kind"),
    15: .same(proto: "attributes"),
    16: .standard(proto: "disconnect_reason"),
    18: .standard(proto: "kind_details"),
  ]

  fileprivate class _StorageClass {
    var _sid: String = String()
    var _identity: String = String()
    var _state: Livekit_ParticipantInfo.State = .joining
    var _tracks: [Livekit_TrackInfo] = []
    var _metadata: String = String()
    var _joinedAt: Int64 = 0
    var _joinedAtMs: Int64 = 0
    var _name: String = String()
    var _version: UInt32 = 0
    var _permission: Livekit_ParticipantPermission? = nil
    var _region: String = String()
    var _isPublisher: Bool = false
    var _kind: Livekit_ParticipantInfo.Kind = .standard
    var _attributes: Dictionary<String,String> = [:]
    var _disconnectReason: Livekit_DisconnectReason = .unknownReason
    var _kindDetails: [Livekit_ParticipantInfo.KindDetail] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sid = source._sid
      _identity = source._identity
      _state = source._state
      _tracks = source._tracks
      _metadata = source._metadata
      _joinedAt = source._joinedAt
      _joinedAtMs = source._joinedAtMs
      _name = source._name
      _version = source._version
      _permission = source._permission
      _region = source._region
      _isPublisher = source._isPublisher
      _kind = source._kind
      _attributes = source._attributes
      _disconnectReason = source._disconnectReason
      _kindDetails = source._kindDetails
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._sid) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._tracks) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._metadata) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._joinedAt) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._version) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._permission) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._region) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._isPublisher) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._kind) }()
        case 15: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._attributes) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._disconnectReason) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._joinedAtMs) }()
        case 18: try { try decoder.decodeRepeatedEnumField(value: &_storage._kindDetails) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._sid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sid, fieldNumber: 1)
      }
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 2)
      }
      if _storage._state != .joining {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
      }
      if !_storage._tracks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tracks, fieldNumber: 4)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitSingularStringField(value: _storage._metadata, fieldNumber: 5)
      }
      if _storage._joinedAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._joinedAt, fieldNumber: 6)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 9)
      }
      if _storage._version != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._version, fieldNumber: 10)
      }
      try { if let v = _storage._permission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._region.isEmpty {
        try visitor.visitSingularStringField(value: _storage._region, fieldNumber: 12)
      }
      if _storage._isPublisher != false {
        try visitor.visitSingularBoolField(value: _storage._isPublisher, fieldNumber: 13)
      }
      if _storage._kind != .standard {
        try visitor.visitSingularEnumField(value: _storage._kind, fieldNumber: 14)
      }
      if !_storage._attributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._attributes, fieldNumber: 15)
      }
      if _storage._disconnectReason != .unknownReason {
        try visitor.visitSingularEnumField(value: _storage._disconnectReason, fieldNumber: 16)
      }
      if _storage._joinedAtMs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._joinedAtMs, fieldNumber: 17)
      }
      if !_storage._kindDetails.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._kindDetails, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_ParticipantInfo, rhs: Livekit_ParticipantInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sid != rhs_storage._sid {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._tracks != rhs_storage._tracks {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._joinedAt != rhs_storage._joinedAt {return false}
        if _storage._joinedAtMs != rhs_storage._joinedAtMs {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._permission != rhs_storage._permission {return false}
        if _storage._region != rhs_storage._region {return false}
        if _storage._isPublisher != rhs_storage._isPublisher {return false}
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._disconnectReason != rhs_storage._disconnectReason {return false}
        if _storage._kindDetails != rhs_storage._kindDetails {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_ParticipantInfo.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "JOINING"),
    1: .same(proto: "JOINED"),
    2: .same(proto: "ACTIVE"),
    3: .same(proto: "DISCONNECTED"),
  ]
}

extension Livekit_ParticipantInfo.Kind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STANDARD"),
    1: .same(proto: "INGRESS"),
    2: .same(proto: "EGRESS"),
    3: .same(proto: "SIP"),
    4: .same(proto: "AGENT"),
  ]
}

extension Livekit_ParticipantInfo.KindDetail: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLOUD_AGENT"),
    1: .same(proto: "FORWARDED"),
  ]
}

extension Livekit_Encryption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Encryption"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_Encryption, rhs: Livekit_Encryption) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_Encryption.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "GCM"),
    2: .same(proto: "CUSTOM"),
  ]
}

extension Livekit_SimulcastCodecInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SimulcastCodecInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mime_type"),
    2: .same(proto: "mid"),
    3: .same(proto: "cid"),
    4: .same(proto: "layers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cid) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 1)
    }
    if !self.mid.isEmpty {
      try visitor.visitSingularStringField(value: self.mid, fieldNumber: 2)
    }
    if !self.cid.isEmpty {
      try visitor.visitSingularStringField(value: self.cid, fieldNumber: 3)
    }
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_SimulcastCodecInfo, rhs: Livekit_SimulcastCodecInfo) -> Bool {
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.mid != rhs.mid {return false}
    if lhs.cid != rhs.cid {return false}
    if lhs.layers != rhs.layers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_TrackInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sid"),
    2: .same(proto: "type"),
    3: .same(proto: "name"),
    4: .same(proto: "muted"),
    5: .same(proto: "width"),
    6: .same(proto: "height"),
    7: .same(proto: "simulcast"),
    8: .standard(proto: "disable_dtx"),
    9: .same(proto: "source"),
    10: .same(proto: "layers"),
    11: .standard(proto: "mime_type"),
    12: .same(proto: "mid"),
    13: .same(proto: "codecs"),
    14: .same(proto: "stereo"),
    15: .standard(proto: "disable_red"),
    16: .same(proto: "encryption"),
    17: .same(proto: "stream"),
    18: .same(proto: "version"),
    19: .standard(proto: "audio_features"),
    20: .standard(proto: "backup_codec_policy"),
  ]

  fileprivate class _StorageClass {
    var _sid: String = String()
    var _type: Livekit_TrackType = .audio
    var _name: String = String()
    var _muted: Bool = false
    var _width: UInt32 = 0
    var _height: UInt32 = 0
    var _simulcast: Bool = false
    var _disableDtx: Bool = false
    var _source: Livekit_TrackSource = .unknown
    var _layers: [Livekit_VideoLayer] = []
    var _mimeType: String = String()
    var _mid: String = String()
    var _codecs: [Livekit_SimulcastCodecInfo] = []
    var _stereo: Bool = false
    var _disableRed: Bool = false
    var _encryption: Livekit_Encryption.TypeEnum = .none
    var _stream: String = String()
    var _version: Livekit_TimedVersion? = nil
    var _audioFeatures: [Livekit_AudioTrackFeature] = []
    var _backupCodecPolicy: Livekit_BackupCodecPolicy = .preferRegression

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sid = source._sid
      _type = source._type
      _name = source._name
      _muted = source._muted
      _width = source._width
      _height = source._height
      _simulcast = source._simulcast
      _disableDtx = source._disableDtx
      _source = source._source
      _layers = source._layers
      _mimeType = source._mimeType
      _mid = source._mid
      _codecs = source._codecs
      _stereo = source._stereo
      _disableRed = source._disableRed
      _encryption = source._encryption
      _stream = source._stream
      _version = source._version
      _audioFeatures = source._audioFeatures
      _backupCodecPolicy = source._backupCodecPolicy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._sid) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._muted) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._width) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._height) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._simulcast) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._disableDtx) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._source) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._layers) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._mimeType) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._mid) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._codecs) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._stereo) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._disableRed) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._encryption) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._stream) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._version) }()
        case 19: try { try decoder.decodeRepeatedEnumField(value: &_storage._audioFeatures) }()
        case 20: try { try decoder.decodeSingularEnumField(value: &_storage._backupCodecPolicy) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._sid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sid, fieldNumber: 1)
      }
      if _storage._type != .audio {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if _storage._muted != false {
        try visitor.visitSingularBoolField(value: _storage._muted, fieldNumber: 4)
      }
      if _storage._width != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._width, fieldNumber: 5)
      }
      if _storage._height != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._height, fieldNumber: 6)
      }
      if _storage._simulcast != false {
        try visitor.visitSingularBoolField(value: _storage._simulcast, fieldNumber: 7)
      }
      if _storage._disableDtx != false {
        try visitor.visitSingularBoolField(value: _storage._disableDtx, fieldNumber: 8)
      }
      if _storage._source != .unknown {
        try visitor.visitSingularEnumField(value: _storage._source, fieldNumber: 9)
      }
      if !_storage._layers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._layers, fieldNumber: 10)
      }
      if !_storage._mimeType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mimeType, fieldNumber: 11)
      }
      if !_storage._mid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mid, fieldNumber: 12)
      }
      if !_storage._codecs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._codecs, fieldNumber: 13)
      }
      if _storage._stereo != false {
        try visitor.visitSingularBoolField(value: _storage._stereo, fieldNumber: 14)
      }
      if _storage._disableRed != false {
        try visitor.visitSingularBoolField(value: _storage._disableRed, fieldNumber: 15)
      }
      if _storage._encryption != .none {
        try visitor.visitSingularEnumField(value: _storage._encryption, fieldNumber: 16)
      }
      if !_storage._stream.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stream, fieldNumber: 17)
      }
      try { if let v = _storage._version {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if !_storage._audioFeatures.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._audioFeatures, fieldNumber: 19)
      }
      if _storage._backupCodecPolicy != .preferRegression {
        try visitor.visitSingularEnumField(value: _storage._backupCodecPolicy, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_TrackInfo, rhs: Livekit_TrackInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sid != rhs_storage._sid {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._muted != rhs_storage._muted {return false}
        if _storage._width != rhs_storage._width {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._simulcast != rhs_storage._simulcast {return false}
        if _storage._disableDtx != rhs_storage._disableDtx {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._layers != rhs_storage._layers {return false}
        if _storage._mimeType != rhs_storage._mimeType {return false}
        if _storage._mid != rhs_storage._mid {return false}
        if _storage._codecs != rhs_storage._codecs {return false}
        if _storage._stereo != rhs_storage._stereo {return false}
        if _storage._disableRed != rhs_storage._disableRed {return false}
        if _storage._encryption != rhs_storage._encryption {return false}
        if _storage._stream != rhs_storage._stream {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._audioFeatures != rhs_storage._audioFeatures {return false}
        if _storage._backupCodecPolicy != rhs_storage._backupCodecPolicy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_VideoLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoLayer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quality"),
    2: .same(proto: "width"),
    3: .same(proto: "height"),
    4: .same(proto: "bitrate"),
    5: .same(proto: "ssrc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.quality) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.bitrate) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.ssrc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.quality != .low {
      try visitor.visitSingularEnumField(value: self.quality, fieldNumber: 1)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 3)
    }
    if self.bitrate != 0 {
      try visitor.visitSingularUInt32Field(value: self.bitrate, fieldNumber: 4)
    }
    if self.ssrc != 0 {
      try visitor.visitSingularUInt32Field(value: self.ssrc, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_VideoLayer, rhs: Livekit_VideoLayer) -> Bool {
    if lhs.quality != rhs.quality {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.bitrate != rhs.bitrate {return false}
    if lhs.ssrc != rhs.ssrc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_DataPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataPacket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    4: .standard(proto: "participant_identity"),
    5: .standard(proto: "destination_identities"),
    2: .same(proto: "user"),
    3: .same(proto: "speaker"),
    6: .standard(proto: "sip_dtmf"),
    7: .same(proto: "transcription"),
    8: .same(proto: "metrics"),
    9: .standard(proto: "chat_message"),
    10: .standard(proto: "rpc_request"),
    11: .standard(proto: "rpc_ack"),
    12: .standard(proto: "rpc_response"),
    13: .standard(proto: "stream_header"),
    14: .standard(proto: "stream_chunk"),
    15: .standard(proto: "stream_trailer"),
    16: .same(proto: "sequence"),
    17: .standard(proto: "participant_sid"),
  ]

  fileprivate class _StorageClass {
    var _kind: Livekit_DataPacket.Kind = .reliable
    var _participantIdentity: String = String()
    var _destinationIdentities: [String] = []
    var _value: Livekit_DataPacket.OneOf_Value?
    var _sequence: UInt32 = 0
    var _participantSid: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _participantIdentity = source._participantIdentity
      _destinationIdentities = source._destinationIdentities
      _value = source._value
      _sequence = source._sequence
      _participantSid = source._participantSid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._kind) }()
        case 2: try {
          var v: Livekit_UserPacket?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .user(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .user(v)
          }
        }()
        case 3: try {
          var v: Livekit_ActiveSpeakerUpdate?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .speaker(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .speaker(v)
          }
        }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._participantIdentity) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._destinationIdentities) }()
        case 6: try {
          var v: Livekit_SipDTMF?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .sipDtmf(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .sipDtmf(v)
          }
        }()
        case 7: try {
          var v: Livekit_Transcription?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .transcription(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .transcription(v)
          }
        }()
        case 8: try {
          var v: Livekit_MetricsBatch?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .metrics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .metrics(v)
          }
        }()
        case 9: try {
          var v: Livekit_ChatMessage?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .chatMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .chatMessage(v)
          }
        }()
        case 10: try {
          var v: Livekit_RpcRequest?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .rpcRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .rpcRequest(v)
          }
        }()
        case 11: try {
          var v: Livekit_RpcAck?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .rpcAck(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .rpcAck(v)
          }
        }()
        case 12: try {
          var v: Livekit_RpcResponse?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .rpcResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .rpcResponse(v)
          }
        }()
        case 13: try {
          var v: Livekit_DataStream.Header?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .streamHeader(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .streamHeader(v)
          }
        }()
        case 14: try {
          var v: Livekit_DataStream.Chunk?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .streamChunk(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .streamChunk(v)
          }
        }()
        case 15: try {
          var v: Livekit_DataStream.Trailer?
          var hadOneofValue = false
          if let current = _storage._value {
            hadOneofValue = true
            if case .streamTrailer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._value = .streamTrailer(v)
          }
        }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._sequence) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._participantSid) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._kind != .reliable {
        try visitor.visitSingularEnumField(value: _storage._kind, fieldNumber: 1)
      }
      switch _storage._value {
      case .user?: try {
        guard case .user(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .speaker?: try {
        guard case .speaker(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      default: break
      }
      if !_storage._participantIdentity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._participantIdentity, fieldNumber: 4)
      }
      if !_storage._destinationIdentities.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._destinationIdentities, fieldNumber: 5)
      }
      switch _storage._value {
      case .sipDtmf?: try {
        guard case .sipDtmf(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .transcription?: try {
        guard case .transcription(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .metrics?: try {
        guard case .metrics(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .chatMessage?: try {
        guard case .chatMessage(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .rpcRequest?: try {
        guard case .rpcRequest(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .rpcAck?: try {
        guard case .rpcAck(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .rpcResponse?: try {
        guard case .rpcResponse(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .streamHeader?: try {
        guard case .streamHeader(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .streamChunk?: try {
        guard case .streamChunk(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .streamTrailer?: try {
        guard case .streamTrailer(let v)? = _storage._value else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      default: break
      }
      if _storage._sequence != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sequence, fieldNumber: 16)
      }
      if !_storage._participantSid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._participantSid, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_DataPacket, rhs: Livekit_DataPacket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._participantIdentity != rhs_storage._participantIdentity {return false}
        if _storage._destinationIdentities != rhs_storage._destinationIdentities {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._sequence != rhs_storage._sequence {return false}
        if _storage._participantSid != rhs_storage._participantSid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_DataPacket.Kind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RELIABLE"),
    1: .same(proto: "LOSSY"),
  ]
}

extension Livekit_ActiveSpeakerUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActiveSpeakerUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "speakers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.speakers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.speakers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.speakers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_ActiveSpeakerUpdate, rhs: Livekit_ActiveSpeakerUpdate) -> Bool {
    if lhs.speakers != rhs.speakers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_SpeakerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpeakerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sid"),
    2: .same(proto: "level"),
    3: .same(proto: "active"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sid) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.level) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sid.isEmpty {
      try visitor.visitSingularStringField(value: self.sid, fieldNumber: 1)
    }
    if self.level.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.level, fieldNumber: 2)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_SpeakerInfo, rhs: Livekit_SpeakerInfo) -> Bool {
    if lhs.sid != rhs.sid {return false}
    if lhs.level != rhs.level {return false}
    if lhs.active != rhs.active {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_UserPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserPacket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "participant_sid"),
    5: .standard(proto: "participant_identity"),
    2: .same(proto: "payload"),
    3: .standard(proto: "destination_sids"),
    6: .standard(proto: "destination_identities"),
    4: .same(proto: "topic"),
    8: .same(proto: "id"),
    9: .standard(proto: "start_time"),
    10: .standard(proto: "end_time"),
    11: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.participantSid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.destinationSids) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._topic) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.participantIdentity) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.destinationIdentities) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self._startTime) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self._endTime) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.participantSid.isEmpty {
      try visitor.visitSingularStringField(value: self.participantSid, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if !self.destinationSids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.destinationSids, fieldNumber: 3)
    }
    try { if let v = self._topic {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.participantIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.participantIdentity, fieldNumber: 5)
    }
    if !self.destinationIdentities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.destinationIdentities, fieldNumber: 6)
    }
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._startTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
    } }()
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_UserPacket, rhs: Livekit_UserPacket) -> Bool {
    if lhs.participantSid != rhs.participantSid {return false}
    if lhs.participantIdentity != rhs.participantIdentity {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.destinationSids != rhs.destinationSids {return false}
    if lhs.destinationIdentities != rhs.destinationIdentities {return false}
    if lhs._topic != rhs._topic {return false}
    if lhs._id != rhs._id {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_SipDTMF: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SipDTMF"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "code"),
    4: .same(proto: "digit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.digit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 3)
    }
    if !self.digit.isEmpty {
      try visitor.visitSingularStringField(value: self.digit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_SipDTMF, rhs: Livekit_SipDTMF) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.digit != rhs.digit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_Transcription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transcription"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "transcribed_participant_identity"),
    3: .standard(proto: "track_id"),
    4: .same(proto: "segments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.transcribedParticipantIdentity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.trackID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.segments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transcribedParticipantIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.transcribedParticipantIdentity, fieldNumber: 2)
    }
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 3)
    }
    if !self.segments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.segments, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_Transcription, rhs: Livekit_Transcription) -> Bool {
    if lhs.transcribedParticipantIdentity != rhs.transcribedParticipantIdentity {return false}
    if lhs.trackID != rhs.trackID {return false}
    if lhs.segments != rhs.segments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_TranscriptionSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TranscriptionSegment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "text"),
    3: .standard(proto: "start_time"),
    4: .standard(proto: "end_time"),
    5: .same(proto: "final"),
    6: .same(proto: "language"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.startTime) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.endTime) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.final) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.language) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    if self.startTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.startTime, fieldNumber: 3)
    }
    if self.endTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.endTime, fieldNumber: 4)
    }
    if self.final != false {
      try visitor.visitSingularBoolField(value: self.final, fieldNumber: 5)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_TranscriptionSegment, rhs: Livekit_TranscriptionSegment) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.text != rhs.text {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.final != rhs.final {return false}
    if lhs.language != rhs.language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_ChatMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChatMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "timestamp"),
    3: .standard(proto: "edit_timestamp"),
    4: .same(proto: "message"),
    5: .same(proto: "deleted"),
    6: .same(proto: "generated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._editTimestamp) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.deleted) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.generated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try { if let v = self._editTimestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 4)
    }
    if self.deleted != false {
      try visitor.visitSingularBoolField(value: self.deleted, fieldNumber: 5)
    }
    if self.generated != false {
      try visitor.visitSingularBoolField(value: self.generated, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_ChatMessage, rhs: Livekit_ChatMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._editTimestamp != rhs._editTimestamp {return false}
    if lhs.message != rhs.message {return false}
    if lhs.deleted != rhs.deleted {return false}
    if lhs.generated != rhs.generated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_RpcRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "method"),
    3: .same(proto: "payload"),
    4: .standard(proto: "response_timeout_ms"),
    5: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.method) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.payload) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.responseTimeoutMs) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.method.isEmpty {
      try visitor.visitSingularStringField(value: self.method, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularStringField(value: self.payload, fieldNumber: 3)
    }
    if self.responseTimeoutMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.responseTimeoutMs, fieldNumber: 4)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_RpcRequest, rhs: Livekit_RpcRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.method != rhs.method {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.responseTimeoutMs != rhs.responseTimeoutMs {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_RpcAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcAck"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_RpcAck, rhs: Livekit_RpcAck) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_RpcResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "payload"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .payload(v)
        }
      }()
      case 3: try {
        var v: Livekit_RpcError?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    switch self.value {
    case .payload?: try {
      guard case .payload(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_RpcResponse, rhs: Livekit_RpcResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_RpcError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_RpcError, rhs: Livekit_RpcError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_ParticipantTracks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantTracks"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "participant_sid"),
    2: .standard(proto: "track_sids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.participantSid) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.trackSids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.participantSid.isEmpty {
      try visitor.visitSingularStringField(value: self.participantSid, fieldNumber: 1)
    }
    if !self.trackSids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.trackSids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_ParticipantTracks, rhs: Livekit_ParticipantTracks) -> Bool {
    if lhs.participantSid != rhs.participantSid {return false}
    if lhs.trackSids != rhs.trackSids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_ServerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "edition"),
    2: .same(proto: "version"),
    3: .same(proto: "protocol"),
    4: .same(proto: "region"),
    5: .standard(proto: "node_id"),
    6: .standard(proto: "debug_info"),
    7: .standard(proto: "agent_protocol"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.edition) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.`protocol`) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nodeID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.debugInfo) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.agentProtocol) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.edition != .standard {
      try visitor.visitSingularEnumField(value: self.edition, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if self.`protocol` != 0 {
      try visitor.visitSingularInt32Field(value: self.`protocol`, fieldNumber: 3)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 4)
    }
    if !self.nodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeID, fieldNumber: 5)
    }
    if !self.debugInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.debugInfo, fieldNumber: 6)
    }
    if self.agentProtocol != 0 {
      try visitor.visitSingularInt32Field(value: self.agentProtocol, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_ServerInfo, rhs: Livekit_ServerInfo) -> Bool {
    if lhs.edition != rhs.edition {return false}
    if lhs.version != rhs.version {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.region != rhs.region {return false}
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.debugInfo != rhs.debugInfo {return false}
    if lhs.agentProtocol != rhs.agentProtocol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_ServerInfo.Edition: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Standard"),
    1: .same(proto: "Cloud"),
  ]
}

extension Livekit_ClientInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sdk"),
    2: .same(proto: "version"),
    3: .same(proto: "protocol"),
    4: .same(proto: "os"),
    5: .standard(proto: "os_version"),
    6: .standard(proto: "device_model"),
    7: .same(proto: "browser"),
    8: .standard(proto: "browser_version"),
    9: .same(proto: "address"),
    10: .same(proto: "network"),
    11: .standard(proto: "other_sdks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.sdk) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.`protocol`) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.os) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.deviceModel) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.browser) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.browserVersion) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.network) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.otherSdks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sdk != .unknown {
      try visitor.visitSingularEnumField(value: self.sdk, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if self.`protocol` != 0 {
      try visitor.visitSingularInt32Field(value: self.`protocol`, fieldNumber: 3)
    }
    if !self.os.isEmpty {
      try visitor.visitSingularStringField(value: self.os, fieldNumber: 4)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 5)
    }
    if !self.deviceModel.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceModel, fieldNumber: 6)
    }
    if !self.browser.isEmpty {
      try visitor.visitSingularStringField(value: self.browser, fieldNumber: 7)
    }
    if !self.browserVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.browserVersion, fieldNumber: 8)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 9)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 10)
    }
    if !self.otherSdks.isEmpty {
      try visitor.visitSingularStringField(value: self.otherSdks, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_ClientInfo, rhs: Livekit_ClientInfo) -> Bool {
    if lhs.sdk != rhs.sdk {return false}
    if lhs.version != rhs.version {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.os != rhs.os {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.deviceModel != rhs.deviceModel {return false}
    if lhs.browser != rhs.browser {return false}
    if lhs.browserVersion != rhs.browserVersion {return false}
    if lhs.address != rhs.address {return false}
    if lhs.network != rhs.network {return false}
    if lhs.otherSdks != rhs.otherSdks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_ClientInfo.SDK: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "JS"),
    2: .same(proto: "SWIFT"),
    3: .same(proto: "ANDROID"),
    4: .same(proto: "FLUTTER"),
    5: .same(proto: "GO"),
    6: .same(proto: "UNITY"),
    7: .same(proto: "REACT_NATIVE"),
    8: .same(proto: "RUST"),
    9: .same(proto: "PYTHON"),
    10: .same(proto: "CPP"),
    11: .same(proto: "UNITY_WEB"),
    12: .same(proto: "NODE"),
    13: .same(proto: "UNREAL"),
  ]
}

extension Livekit_ClientConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "video"),
    2: .same(proto: "screen"),
    3: .standard(proto: "resume_connection"),
    4: .standard(proto: "disabled_codecs"),
    5: .standard(proto: "force_relay"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._video) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._screen) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.resumeConnection) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._disabledCodecs) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.forceRelay) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._video {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._screen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.resumeConnection != .unset {
      try visitor.visitSingularEnumField(value: self.resumeConnection, fieldNumber: 3)
    }
    try { if let v = self._disabledCodecs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.forceRelay != .unset {
      try visitor.visitSingularEnumField(value: self.forceRelay, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_ClientConfiguration, rhs: Livekit_ClientConfiguration) -> Bool {
    if lhs._video != rhs._video {return false}
    if lhs._screen != rhs._screen {return false}
    if lhs.resumeConnection != rhs.resumeConnection {return false}
    if lhs._disabledCodecs != rhs._disabledCodecs {return false}
    if lhs.forceRelay != rhs.forceRelay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_VideoConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hardware_encoder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.hardwareEncoder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hardwareEncoder != .unset {
      try visitor.visitSingularEnumField(value: self.hardwareEncoder, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_VideoConfiguration, rhs: Livekit_VideoConfiguration) -> Bool {
    if lhs.hardwareEncoder != rhs.hardwareEncoder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_DisabledCodecs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisabledCodecs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codecs"),
    2: .same(proto: "publish"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.codecs) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.publish) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.codecs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.codecs, fieldNumber: 1)
    }
    if !self.publish.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publish, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_DisabledCodecs, rhs: Livekit_DisabledCodecs) -> Bool {
    if lhs.codecs != rhs.codecs {return false}
    if lhs.publish != rhs.publish {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_RTPDrift: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTPDrift"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
    3: .same(proto: "duration"),
    4: .standard(proto: "start_timestamp"),
    5: .standard(proto: "end_timestamp"),
    6: .standard(proto: "rtp_clock_ticks"),
    7: .standard(proto: "drift_samples"),
    8: .standard(proto: "drift_ms"),
    9: .standard(proto: "clock_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.duration) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.startTimestamp) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.endTimestamp) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.rtpClockTicks) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.driftSamples) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.driftMs) }()
      case 9: try { try decoder.decodeSingularDoubleField(value: &self.clockRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.duration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 3)
    }
    if self.startTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.startTimestamp, fieldNumber: 4)
    }
    if self.endTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.endTimestamp, fieldNumber: 5)
    }
    if self.rtpClockTicks != 0 {
      try visitor.visitSingularUInt64Field(value: self.rtpClockTicks, fieldNumber: 6)
    }
    if self.driftSamples != 0 {
      try visitor.visitSingularInt64Field(value: self.driftSamples, fieldNumber: 7)
    }
    if self.driftMs.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.driftMs, fieldNumber: 8)
    }
    if self.clockRate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.clockRate, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_RTPDrift, rhs: Livekit_RTPDrift) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.startTimestamp != rhs.startTimestamp {return false}
    if lhs.endTimestamp != rhs.endTimestamp {return false}
    if lhs.rtpClockTicks != rhs.rtpClockTicks {return false}
    if lhs.driftSamples != rhs.driftSamples {return false}
    if lhs.driftMs != rhs.driftMs {return false}
    if lhs.clockRate != rhs.clockRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_RTPStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTPStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
    3: .same(proto: "duration"),
    4: .same(proto: "packets"),
    5: .standard(proto: "packet_rate"),
    6: .same(proto: "bytes"),
    39: .standard(proto: "header_bytes"),
    7: .same(proto: "bitrate"),
    8: .standard(proto: "packets_lost"),
    9: .standard(proto: "packet_loss_rate"),
    10: .standard(proto: "packet_loss_percentage"),
    11: .standard(proto: "packets_duplicate"),
    12: .standard(proto: "packet_duplicate_rate"),
    13: .standard(proto: "bytes_duplicate"),
    40: .standard(proto: "header_bytes_duplicate"),
    14: .standard(proto: "bitrate_duplicate"),
    15: .standard(proto: "packets_padding"),
    16: .standard(proto: "packet_padding_rate"),
    17: .standard(proto: "bytes_padding"),
    41: .standard(proto: "header_bytes_padding"),
    18: .standard(proto: "bitrate_padding"),
    19: .standard(proto: "packets_out_of_order"),
    20: .same(proto: "frames"),
    21: .standard(proto: "frame_rate"),
    22: .standard(proto: "jitter_current"),
    23: .standard(proto: "jitter_max"),
    24: .standard(proto: "gap_histogram"),
    25: .same(proto: "nacks"),
    37: .standard(proto: "nack_acks"),
    26: .standard(proto: "nack_misses"),
    38: .standard(proto: "nack_repeated"),
    27: .same(proto: "plis"),
    28: .standard(proto: "last_pli"),
    29: .same(proto: "firs"),
    30: .standard(proto: "last_fir"),
    31: .standard(proto: "rtt_current"),
    32: .standard(proto: "rtt_max"),
    33: .standard(proto: "key_frames"),
    34: .standard(proto: "last_key_frame"),
    35: .standard(proto: "layer_lock_plis"),
    36: .standard(proto: "last_layer_lock_pli"),
    44: .standard(proto: "packet_drift"),
    45: .standard(proto: "ntp_report_drift"),
    46: .standard(proto: "rebased_report_drift"),
    47: .standard(proto: "received_report_drift"),
  ]

  fileprivate class _StorageClass {
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _duration: Double = 0
    var _packets: UInt32 = 0
    var _packetRate: Double = 0
    var _bytes: UInt64 = 0
    var _headerBytes: UInt64 = 0
    var _bitrate: Double = 0
    var _packetsLost: UInt32 = 0
    var _packetLossRate: Double = 0
    var _packetLossPercentage: Float = 0
    var _packetsDuplicate: UInt32 = 0
    var _packetDuplicateRate: Double = 0
    var _bytesDuplicate: UInt64 = 0
    var _headerBytesDuplicate: UInt64 = 0
    var _bitrateDuplicate: Double = 0
    var _packetsPadding: UInt32 = 0
    var _packetPaddingRate: Double = 0
    var _bytesPadding: UInt64 = 0
    var _headerBytesPadding: UInt64 = 0
    var _bitratePadding: Double = 0
    var _packetsOutOfOrder: UInt32 = 0
    var _frames: UInt32 = 0
    var _frameRate: Double = 0
    var _jitterCurrent: Double = 0
    var _jitterMax: Double = 0
    var _gapHistogram: Dictionary<Int32,UInt32> = [:]
    var _nacks: UInt32 = 0
    var _nackAcks: UInt32 = 0
    var _nackMisses: UInt32 = 0
    var _nackRepeated: UInt32 = 0
    var _plis: UInt32 = 0
    var _lastPli: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _firs: UInt32 = 0
    var _lastFir: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _rttCurrent: UInt32 = 0
    var _rttMax: UInt32 = 0
    var _keyFrames: UInt32 = 0
    var _lastKeyFrame: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _layerLockPlis: UInt32 = 0
    var _lastLayerLockPli: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _packetDrift: Livekit_RTPDrift? = nil
    var _ntpReportDrift: Livekit_RTPDrift? = nil
    var _rebasedReportDrift: Livekit_RTPDrift? = nil
    var _receivedReportDrift: Livekit_RTPDrift? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _startTime = source._startTime
      _endTime = source._endTime
      _duration = source._duration
      _packets = source._packets
      _packetRate = source._packetRate
      _bytes = source._bytes
      _headerBytes = source._headerBytes
      _bitrate = source._bitrate
      _packetsLost = source._packetsLost
      _packetLossRate = source._packetLossRate
      _packetLossPercentage = source._packetLossPercentage
      _packetsDuplicate = source._packetsDuplicate
      _packetDuplicateRate = source._packetDuplicateRate
      _bytesDuplicate = source._bytesDuplicate
      _headerBytesDuplicate = source._headerBytesDuplicate
      _bitrateDuplicate = source._bitrateDuplicate
      _packetsPadding = source._packetsPadding
      _packetPaddingRate = source._packetPaddingRate
      _bytesPadding = source._bytesPadding
      _headerBytesPadding = source._headerBytesPadding
      _bitratePadding = source._bitratePadding
      _packetsOutOfOrder = source._packetsOutOfOrder
      _frames = source._frames
      _frameRate = source._frameRate
      _jitterCurrent = source._jitterCurrent
      _jitterMax = source._jitterMax
      _gapHistogram = source._gapHistogram
      _nacks = source._nacks
      _nackAcks = source._nackAcks
      _nackMisses = source._nackMisses
      _nackRepeated = source._nackRepeated
      _plis = source._plis
      _lastPli = source._lastPli
      _firs = source._firs
      _lastFir = source._lastFir
      _rttCurrent = source._rttCurrent
      _rttMax = source._rttMax
      _keyFrames = source._keyFrames
      _lastKeyFrame = source._lastKeyFrame
      _layerLockPlis = source._layerLockPlis
      _lastLayerLockPli = source._lastLayerLockPli
      _packetDrift = source._packetDrift
      _ntpReportDrift = source._ntpReportDrift
      _rebasedReportDrift = source._rebasedReportDrift
      _receivedReportDrift = source._receivedReportDrift
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._duration) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._packets) }()
        case 5: try { try decoder.decodeSingularDoubleField(value: &_storage._packetRate) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._bytes) }()
        case 7: try { try decoder.decodeSingularDoubleField(value: &_storage._bitrate) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._packetsLost) }()
        case 9: try { try decoder.decodeSingularDoubleField(value: &_storage._packetLossRate) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._packetLossPercentage) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._packetsDuplicate) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._packetDuplicateRate) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._bytesDuplicate) }()
        case 14: try { try decoder.decodeSingularDoubleField(value: &_storage._bitrateDuplicate) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._packetsPadding) }()
        case 16: try { try decoder.decodeSingularDoubleField(value: &_storage._packetPaddingRate) }()
        case 17: try { try decoder.decodeSingularUInt64Field(value: &_storage._bytesPadding) }()
        case 18: try { try decoder.decodeSingularDoubleField(value: &_storage._bitratePadding) }()
        case 19: try { try decoder.decodeSingularUInt32Field(value: &_storage._packetsOutOfOrder) }()
        case 20: try { try decoder.decodeSingularUInt32Field(value: &_storage._frames) }()
        case 21: try { try decoder.decodeSingularDoubleField(value: &_storage._frameRate) }()
        case 22: try { try decoder.decodeSingularDoubleField(value: &_storage._jitterCurrent) }()
        case 23: try { try decoder.decodeSingularDoubleField(value: &_storage._jitterMax) }()
        case 24: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufUInt32>.self, value: &_storage._gapHistogram) }()
        case 25: try { try decoder.decodeSingularUInt32Field(value: &_storage._nacks) }()
        case 26: try { try decoder.decodeSingularUInt32Field(value: &_storage._nackMisses) }()
        case 27: try { try decoder.decodeSingularUInt32Field(value: &_storage._plis) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._lastPli) }()
        case 29: try { try decoder.decodeSingularUInt32Field(value: &_storage._firs) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._lastFir) }()
        case 31: try { try decoder.decodeSingularUInt32Field(value: &_storage._rttCurrent) }()
        case 32: try { try decoder.decodeSingularUInt32Field(value: &_storage._rttMax) }()
        case 33: try { try decoder.decodeSingularUInt32Field(value: &_storage._keyFrames) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._lastKeyFrame) }()
        case 35: try { try decoder.decodeSingularUInt32Field(value: &_storage._layerLockPlis) }()
        case 36: try { try decoder.decodeSingularMessageField(value: &_storage._lastLayerLockPli) }()
        case 37: try { try decoder.decodeSingularUInt32Field(value: &_storage._nackAcks) }()
        case 38: try { try decoder.decodeSingularUInt32Field(value: &_storage._nackRepeated) }()
        case 39: try { try decoder.decodeSingularUInt64Field(value: &_storage._headerBytes) }()
        case 40: try { try decoder.decodeSingularUInt64Field(value: &_storage._headerBytesDuplicate) }()
        case 41: try { try decoder.decodeSingularUInt64Field(value: &_storage._headerBytesPadding) }()
        case 44: try { try decoder.decodeSingularMessageField(value: &_storage._packetDrift) }()
        case 45: try { try decoder.decodeSingularMessageField(value: &_storage._ntpReportDrift) }()
        case 46: try { try decoder.decodeSingularMessageField(value: &_storage._rebasedReportDrift) }()
        case 47: try { try decoder.decodeSingularMessageField(value: &_storage._receivedReportDrift) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._duration.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._duration, fieldNumber: 3)
      }
      if _storage._packets != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._packets, fieldNumber: 4)
      }
      if _storage._packetRate.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._packetRate, fieldNumber: 5)
      }
      if _storage._bytes != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._bytes, fieldNumber: 6)
      }
      if _storage._bitrate.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._bitrate, fieldNumber: 7)
      }
      if _storage._packetsLost != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._packetsLost, fieldNumber: 8)
      }
      if _storage._packetLossRate.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._packetLossRate, fieldNumber: 9)
      }
      if _storage._packetLossPercentage.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._packetLossPercentage, fieldNumber: 10)
      }
      if _storage._packetsDuplicate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._packetsDuplicate, fieldNumber: 11)
      }
      if _storage._packetDuplicateRate.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._packetDuplicateRate, fieldNumber: 12)
      }
      if _storage._bytesDuplicate != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._bytesDuplicate, fieldNumber: 13)
      }
      if _storage._bitrateDuplicate.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._bitrateDuplicate, fieldNumber: 14)
      }
      if _storage._packetsPadding != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._packetsPadding, fieldNumber: 15)
      }
      if _storage._packetPaddingRate.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._packetPaddingRate, fieldNumber: 16)
      }
      if _storage._bytesPadding != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._bytesPadding, fieldNumber: 17)
      }
      if _storage._bitratePadding.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._bitratePadding, fieldNumber: 18)
      }
      if _storage._packetsOutOfOrder != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._packetsOutOfOrder, fieldNumber: 19)
      }
      if _storage._frames != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._frames, fieldNumber: 20)
      }
      if _storage._frameRate.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._frameRate, fieldNumber: 21)
      }
      if _storage._jitterCurrent.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._jitterCurrent, fieldNumber: 22)
      }
      if _storage._jitterMax.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._jitterMax, fieldNumber: 23)
      }
      if !_storage._gapHistogram.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufUInt32>.self, value: _storage._gapHistogram, fieldNumber: 24)
      }
      if _storage._nacks != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._nacks, fieldNumber: 25)
      }
      if _storage._nackMisses != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._nackMisses, fieldNumber: 26)
      }
      if _storage._plis != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._plis, fieldNumber: 27)
      }
      try { if let v = _storage._lastPli {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      if _storage._firs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._firs, fieldNumber: 29)
      }
      try { if let v = _storage._lastFir {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      if _storage._rttCurrent != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rttCurrent, fieldNumber: 31)
      }
      if _storage._rttMax != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rttMax, fieldNumber: 32)
      }
      if _storage._keyFrames != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._keyFrames, fieldNumber: 33)
      }
      try { if let v = _storage._lastKeyFrame {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      } }()
      if _storage._layerLockPlis != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._layerLockPlis, fieldNumber: 35)
      }
      try { if let v = _storage._lastLayerLockPli {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      } }()
      if _storage._nackAcks != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._nackAcks, fieldNumber: 37)
      }
      if _storage._nackRepeated != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._nackRepeated, fieldNumber: 38)
      }
      if _storage._headerBytes != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._headerBytes, fieldNumber: 39)
      }
      if _storage._headerBytesDuplicate != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._headerBytesDuplicate, fieldNumber: 40)
      }
      if _storage._headerBytesPadding != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._headerBytesPadding, fieldNumber: 41)
      }
      try { if let v = _storage._packetDrift {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._ntpReportDrift {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._rebasedReportDrift {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      } }()
      try { if let v = _storage._receivedReportDrift {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_RTPStats, rhs: Livekit_RTPStats) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._packets != rhs_storage._packets {return false}
        if _storage._packetRate != rhs_storage._packetRate {return false}
        if _storage._bytes != rhs_storage._bytes {return false}
        if _storage._headerBytes != rhs_storage._headerBytes {return false}
        if _storage._bitrate != rhs_storage._bitrate {return false}
        if _storage._packetsLost != rhs_storage._packetsLost {return false}
        if _storage._packetLossRate != rhs_storage._packetLossRate {return false}
        if _storage._packetLossPercentage != rhs_storage._packetLossPercentage {return false}
        if _storage._packetsDuplicate != rhs_storage._packetsDuplicate {return false}
        if _storage._packetDuplicateRate != rhs_storage._packetDuplicateRate {return false}
        if _storage._bytesDuplicate != rhs_storage._bytesDuplicate {return false}
        if _storage._headerBytesDuplicate != rhs_storage._headerBytesDuplicate {return false}
        if _storage._bitrateDuplicate != rhs_storage._bitrateDuplicate {return false}
        if _storage._packetsPadding != rhs_storage._packetsPadding {return false}
        if _storage._packetPaddingRate != rhs_storage._packetPaddingRate {return false}
        if _storage._bytesPadding != rhs_storage._bytesPadding {return false}
        if _storage._headerBytesPadding != rhs_storage._headerBytesPadding {return false}
        if _storage._bitratePadding != rhs_storage._bitratePadding {return false}
        if _storage._packetsOutOfOrder != rhs_storage._packetsOutOfOrder {return false}
        if _storage._frames != rhs_storage._frames {return false}
        if _storage._frameRate != rhs_storage._frameRate {return false}
        if _storage._jitterCurrent != rhs_storage._jitterCurrent {return false}
        if _storage._jitterMax != rhs_storage._jitterMax {return false}
        if _storage._gapHistogram != rhs_storage._gapHistogram {return false}
        if _storage._nacks != rhs_storage._nacks {return false}
        if _storage._nackAcks != rhs_storage._nackAcks {return false}
        if _storage._nackMisses != rhs_storage._nackMisses {return false}
        if _storage._nackRepeated != rhs_storage._nackRepeated {return false}
        if _storage._plis != rhs_storage._plis {return false}
        if _storage._lastPli != rhs_storage._lastPli {return false}
        if _storage._firs != rhs_storage._firs {return false}
        if _storage._lastFir != rhs_storage._lastFir {return false}
        if _storage._rttCurrent != rhs_storage._rttCurrent {return false}
        if _storage._rttMax != rhs_storage._rttMax {return false}
        if _storage._keyFrames != rhs_storage._keyFrames {return false}
        if _storage._lastKeyFrame != rhs_storage._lastKeyFrame {return false}
        if _storage._layerLockPlis != rhs_storage._layerLockPlis {return false}
        if _storage._lastLayerLockPli != rhs_storage._lastLayerLockPli {return false}
        if _storage._packetDrift != rhs_storage._packetDrift {return false}
        if _storage._ntpReportDrift != rhs_storage._ntpReportDrift {return false}
        if _storage._rebasedReportDrift != rhs_storage._rebasedReportDrift {return false}
        if _storage._receivedReportDrift != rhs_storage._receivedReportDrift {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_RTCPSenderReportState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTCPSenderReportState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rtp_timestamp"),
    2: .standard(proto: "rtp_timestamp_ext"),
    3: .standard(proto: "ntp_timestamp"),
    4: .same(proto: "at"),
    5: .standard(proto: "at_adjusted"),
    6: .same(proto: "packets"),
    7: .same(proto: "octets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.rtpTimestamp) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.rtpTimestampExt) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.ntpTimestamp) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.at) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.atAdjusted) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.packets) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.octets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rtpTimestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.rtpTimestamp, fieldNumber: 1)
    }
    if self.rtpTimestampExt != 0 {
      try visitor.visitSingularUInt64Field(value: self.rtpTimestampExt, fieldNumber: 2)
    }
    if self.ntpTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.ntpTimestamp, fieldNumber: 3)
    }
    if self.at != 0 {
      try visitor.visitSingularInt64Field(value: self.at, fieldNumber: 4)
    }
    if self.atAdjusted != 0 {
      try visitor.visitSingularInt64Field(value: self.atAdjusted, fieldNumber: 5)
    }
    if self.packets != 0 {
      try visitor.visitSingularUInt32Field(value: self.packets, fieldNumber: 6)
    }
    if self.octets != 0 {
      try visitor.visitSingularUInt64Field(value: self.octets, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_RTCPSenderReportState, rhs: Livekit_RTCPSenderReportState) -> Bool {
    if lhs.rtpTimestamp != rhs.rtpTimestamp {return false}
    if lhs.rtpTimestampExt != rhs.rtpTimestampExt {return false}
    if lhs.ntpTimestamp != rhs.ntpTimestamp {return false}
    if lhs.at != rhs.at {return false}
    if lhs.atAdjusted != rhs.atAdjusted {return false}
    if lhs.packets != rhs.packets {return false}
    if lhs.octets != rhs.octets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_RTPForwarderState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTPForwarderState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "started"),
    2: .standard(proto: "reference_layer_spatial"),
    3: .standard(proto: "pre_start_time"),
    4: .standard(proto: "ext_first_timestamp"),
    5: .standard(proto: "dummy_start_timestamp_offset"),
    6: .standard(proto: "rtp_munger"),
    7: .standard(proto: "vp8_munger"),
    8: .standard(proto: "sender_report_state"),
  ]

  fileprivate class _StorageClass {
    var _started: Bool = false
    var _referenceLayerSpatial: Int32 = 0
    var _preStartTime: Int64 = 0
    var _extFirstTimestamp: UInt64 = 0
    var _dummyStartTimestampOffset: UInt64 = 0
    var _rtpMunger: Livekit_RTPMungerState? = nil
    var _codecMunger: Livekit_RTPForwarderState.OneOf_CodecMunger?
    var _senderReportState: [Livekit_RTCPSenderReportState] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _started = source._started
      _referenceLayerSpatial = source._referenceLayerSpatial
      _preStartTime = source._preStartTime
      _extFirstTimestamp = source._extFirstTimestamp
      _dummyStartTimestampOffset = source._dummyStartTimestampOffset
      _rtpMunger = source._rtpMunger
      _codecMunger = source._codecMunger
      _senderReportState = source._senderReportState
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._started) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._referenceLayerSpatial) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._preStartTime) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._extFirstTimestamp) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._dummyStartTimestampOffset) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._rtpMunger) }()
        case 7: try {
          var v: Livekit_VP8MungerState?
          var hadOneofValue = false
          if let current = _storage._codecMunger {
            hadOneofValue = true
            if case .vp8Munger(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._codecMunger = .vp8Munger(v)
          }
        }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._senderReportState) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._started != false {
        try visitor.visitSingularBoolField(value: _storage._started, fieldNumber: 1)
      }
      if _storage._referenceLayerSpatial != 0 {
        try visitor.visitSingularInt32Field(value: _storage._referenceLayerSpatial, fieldNumber: 2)
      }
      if _storage._preStartTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._preStartTime, fieldNumber: 3)
      }
      if _storage._extFirstTimestamp != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._extFirstTimestamp, fieldNumber: 4)
      }
      if _storage._dummyStartTimestampOffset != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._dummyStartTimestampOffset, fieldNumber: 5)
      }
      try { if let v = _storage._rtpMunger {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if case .vp8Munger(let v)? = _storage._codecMunger {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._senderReportState.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._senderReportState, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_RTPForwarderState, rhs: Livekit_RTPForwarderState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._started != rhs_storage._started {return false}
        if _storage._referenceLayerSpatial != rhs_storage._referenceLayerSpatial {return false}
        if _storage._preStartTime != rhs_storage._preStartTime {return false}
        if _storage._extFirstTimestamp != rhs_storage._extFirstTimestamp {return false}
        if _storage._dummyStartTimestampOffset != rhs_storage._dummyStartTimestampOffset {return false}
        if _storage._rtpMunger != rhs_storage._rtpMunger {return false}
        if _storage._codecMunger != rhs_storage._codecMunger {return false}
        if _storage._senderReportState != rhs_storage._senderReportState {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_RTPMungerState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTPMungerState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ext_last_sequence_number"),
    2: .standard(proto: "ext_second_last_sequence_number"),
    3: .standard(proto: "ext_last_timestamp"),
    4: .standard(proto: "ext_second_last_timestamp"),
    5: .standard(proto: "last_marker"),
    6: .standard(proto: "second_last_marker"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.extLastSequenceNumber) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.extSecondLastSequenceNumber) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.extLastTimestamp) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.extSecondLastTimestamp) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.lastMarker) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.secondLastMarker) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.extLastSequenceNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.extLastSequenceNumber, fieldNumber: 1)
    }
    if self.extSecondLastSequenceNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.extSecondLastSequenceNumber, fieldNumber: 2)
    }
    if self.extLastTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.extLastTimestamp, fieldNumber: 3)
    }
    if self.extSecondLastTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.extSecondLastTimestamp, fieldNumber: 4)
    }
    if self.lastMarker != false {
      try visitor.visitSingularBoolField(value: self.lastMarker, fieldNumber: 5)
    }
    if self.secondLastMarker != false {
      try visitor.visitSingularBoolField(value: self.secondLastMarker, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_RTPMungerState, rhs: Livekit_RTPMungerState) -> Bool {
    if lhs.extLastSequenceNumber != rhs.extLastSequenceNumber {return false}
    if lhs.extSecondLastSequenceNumber != rhs.extSecondLastSequenceNumber {return false}
    if lhs.extLastTimestamp != rhs.extLastTimestamp {return false}
    if lhs.extSecondLastTimestamp != rhs.extSecondLastTimestamp {return false}
    if lhs.lastMarker != rhs.lastMarker {return false}
    if lhs.secondLastMarker != rhs.secondLastMarker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_VP8MungerState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VP8MungerState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ext_last_picture_id"),
    2: .standard(proto: "picture_id_used"),
    3: .standard(proto: "last_tl0_pic_idx"),
    4: .standard(proto: "tl0_pic_idx_used"),
    5: .standard(proto: "tid_used"),
    6: .standard(proto: "last_key_idx"),
    7: .standard(proto: "key_idx_used"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.extLastPictureID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.pictureIDUsed) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.lastTl0PicIdx) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.tl0PicIdxUsed) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.tidUsed) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.lastKeyIdx) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.keyIdxUsed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.extLastPictureID != 0 {
      try visitor.visitSingularInt32Field(value: self.extLastPictureID, fieldNumber: 1)
    }
    if self.pictureIDUsed != false {
      try visitor.visitSingularBoolField(value: self.pictureIDUsed, fieldNumber: 2)
    }
    if self.lastTl0PicIdx != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastTl0PicIdx, fieldNumber: 3)
    }
    if self.tl0PicIdxUsed != false {
      try visitor.visitSingularBoolField(value: self.tl0PicIdxUsed, fieldNumber: 4)
    }
    if self.tidUsed != false {
      try visitor.visitSingularBoolField(value: self.tidUsed, fieldNumber: 5)
    }
    if self.lastKeyIdx != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastKeyIdx, fieldNumber: 6)
    }
    if self.keyIdxUsed != false {
      try visitor.visitSingularBoolField(value: self.keyIdxUsed, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_VP8MungerState, rhs: Livekit_VP8MungerState) -> Bool {
    if lhs.extLastPictureID != rhs.extLastPictureID {return false}
    if lhs.pictureIDUsed != rhs.pictureIDUsed {return false}
    if lhs.lastTl0PicIdx != rhs.lastTl0PicIdx {return false}
    if lhs.tl0PicIdxUsed != rhs.tl0PicIdxUsed {return false}
    if lhs.tidUsed != rhs.tidUsed {return false}
    if lhs.lastKeyIdx != rhs.lastKeyIdx {return false}
    if lhs.keyIdxUsed != rhs.keyIdxUsed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_TimedVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimedVersion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unix_micro"),
    2: .same(proto: "ticks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.unixMicro) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.ticks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unixMicro != 0 {
      try visitor.visitSingularInt64Field(value: self.unixMicro, fieldNumber: 1)
    }
    if self.ticks != 0 {
      try visitor.visitSingularInt32Field(value: self.ticks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_TimedVersion, rhs: Livekit_TimedVersion) -> Bool {
    if lhs.unixMicro != rhs.unixMicro {return false}
    if lhs.ticks != rhs.ticks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_DataStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataStream"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_DataStream, rhs: Livekit_DataStream) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_DataStream.OperationType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CREATE"),
    1: .same(proto: "UPDATE"),
    2: .same(proto: "DELETE"),
    3: .same(proto: "REACTION"),
  ]
}

extension Livekit_DataStream.TextHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Livekit_DataStream.protoMessageName + ".TextHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "operation_type"),
    2: .same(proto: "version"),
    3: .standard(proto: "reply_to_stream_id"),
    4: .standard(proto: "attached_stream_ids"),
    5: .same(proto: "generated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operationType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.replyToStreamID) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.attachedStreamIds) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.generated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operationType != .create {
      try visitor.visitSingularEnumField(value: self.operationType, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    if !self.replyToStreamID.isEmpty {
      try visitor.visitSingularStringField(value: self.replyToStreamID, fieldNumber: 3)
    }
    if !self.attachedStreamIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.attachedStreamIds, fieldNumber: 4)
    }
    if self.generated != false {
      try visitor.visitSingularBoolField(value: self.generated, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_DataStream.TextHeader, rhs: Livekit_DataStream.TextHeader) -> Bool {
    if lhs.operationType != rhs.operationType {return false}
    if lhs.version != rhs.version {return false}
    if lhs.replyToStreamID != rhs.replyToStreamID {return false}
    if lhs.attachedStreamIds != rhs.attachedStreamIds {return false}
    if lhs.generated != rhs.generated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_DataStream.ByteHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Livekit_DataStream.protoMessageName + ".ByteHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_DataStream.ByteHeader, rhs: Livekit_DataStream.ByteHeader) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_DataStream.Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Livekit_DataStream.protoMessageName + ".Header"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "topic"),
    4: .standard(proto: "mime_type"),
    5: .standard(proto: "total_length"),
    7: .standard(proto: "encryption_type"),
    8: .same(proto: "attributes"),
    9: .standard(proto: "text_header"),
    10: .standard(proto: "byte_header"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._totalLength) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.encryptionType) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attributes) }()
      case 9: try {
        var v: Livekit_DataStream.TextHeader?
        var hadOneofValue = false
        if let current = self.contentHeader {
          hadOneofValue = true
          if case .textHeader(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.contentHeader = .textHeader(v)
        }
      }()
      case 10: try {
        var v: Livekit_DataStream.ByteHeader?
        var hadOneofValue = false
        if let current = self.contentHeader {
          hadOneofValue = true
          if case .byteHeader(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.contentHeader = .byteHeader(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 3)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 4)
    }
    try { if let v = self._totalLength {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    if self.encryptionType != .none {
      try visitor.visitSingularEnumField(value: self.encryptionType, fieldNumber: 7)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attributes, fieldNumber: 8)
    }
    switch self.contentHeader {
    case .textHeader?: try {
      guard case .textHeader(let v)? = self.contentHeader else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .byteHeader?: try {
      guard case .byteHeader(let v)? = self.contentHeader else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_DataStream.Header, rhs: Livekit_DataStream.Header) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs._totalLength != rhs._totalLength {return false}
    if lhs.encryptionType != rhs.encryptionType {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.contentHeader != rhs.contentHeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_DataStream.Chunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Livekit_DataStream.protoMessageName + ".Chunk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id"),
    2: .standard(proto: "chunk_index"),
    3: .same(proto: "content"),
    4: .same(proto: "version"),
    5: .same(proto: "iv"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.chunkIndex) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._iv) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if self.chunkIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.chunkIndex, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 3)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 4)
    }
    try { if let v = self._iv {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_DataStream.Chunk, rhs: Livekit_DataStream.Chunk) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.chunkIndex != rhs.chunkIndex {return false}
    if lhs.content != rhs.content {return false}
    if lhs.version != rhs.version {return false}
    if lhs._iv != rhs._iv {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_DataStream.Trailer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Livekit_DataStream.protoMessageName + ".Trailer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id"),
    2: .same(proto: "reason"),
    3: .same(proto: "attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attributes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_DataStream.Trailer, rhs: Livekit_DataStream.Trailer) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Livekit_WebhookConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WebhookConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .standard(proto: "signing_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.signingKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.signingKey.isEmpty {
      try visitor.visitSingularStringField(value: self.signingKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Livekit_WebhookConfig, rhs: Livekit_WebhookConfig) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.signingKey != rhs.signingKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
